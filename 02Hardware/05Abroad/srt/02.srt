1
00:00:01,266 --> 00:00:03,700
字幕生成：mkwei  字幕校准：mkwei

2
00:00:05,000 --> 00:00:05,733
哈喽大家好

3
00:00:05,733 --> 00:00:07,166
我是你们胖胖的 ZOMI

4
00:00:07,166 --> 00:00:08,600
减肥真的没那么容易

5
00:00:08,600 --> 00:00:10,333
每块肉都有他的脾气

6
00:00:10,333 --> 00:00:10,766
今天呢

7
00:00:10,766 --> 00:00:14,366
我们来到了 AI 芯片里面的 NPU 详解

8
00:00:15,300 --> 00:00:16,900
根据我们上一节的内容呢

9
00:00:16,900 --> 00:00:20,100
讲了特斯拉 DOJO 里面的整体的概念

10
00:00:20,100 --> 00:00:20,566
之后呢

11
00:00:20,566 --> 00:00:23,100
今天我们看一下 DOJO 里面的核心

12
00:00:23,133 --> 00:00:24,766
也就是 DOJO Core

13
00:00:25,200 --> 00:00:26,400
现在呢我们回顾一下

14
00:00:26,400 --> 00:00:27,933
在整个系列课程里面呢

15
00:00:27,933 --> 00:00:31,133
我们已经处于 AI 专用处理器里面的

16
00:00:31,133 --> 00:00:32,066
第三个内容

17
00:00:32,266 --> 00:00:33,466
DOJO 的架构

18
00:00:33,500 --> 00:00:35,866
那我们在整个 DOJO 的系列里面呢

19
00:00:35,866 --> 00:00:37,766
之前讲了 DOJO 的整体的架构

20
00:00:37,766 --> 00:00:40,100
今天我们深入的来到了 DOJO Core

21
00:00:40,100 --> 00:00:43,400
我们会分开 4 个内容给大家去汇报的

22
00:00:43,400 --> 00:00:45,533
第一个呢就是 DOJO Core 的整体的架构

23
00:00:45,533 --> 00:00:48,266
然后我们看一下 DOJO Core 的前端的处理

24
00:00:48,533 --> 00:00:48,900
接着呢

25
00:00:48,900 --> 00:00:51,366
我们去看一下 DOJO Core 的执行引擎

26
00:00:51,366 --> 00:00:53,666
最后呢我们看一下 DOJO Core 里面的 SRAM

27
00:00:53,666 --> 00:00:54,600
和它的内存

28
00:00:54,600 --> 00:00:56,166
到底是怎么去排布的

29
00:00:56,166 --> 00:00:59,600
因为 DOJO 它属于一个存算一体的架构

30
00:00:59,600 --> 00:01:02,900
这里面的 SRAM 的内存呢就很有意思了

31
00:01:04,066 --> 00:01:06,100
在正式进入 DOJO Core 之前呢

32
00:01:06,100 --> 00:01:07,900
我想跟大家一起去回顾一下

33
00:01:07,900 --> 00:01:10,300
DOJO 的整个整体的结构

34
00:01:10,366 --> 00:01:10,866
首先呢

35
00:01:10,866 --> 00:01:13,666
DOJO 采用的是一个存算一体的架构

36
00:01:13,666 --> 00:01:14,400
这个架构呢

37
00:01:14,400 --> 00:01:15,100
就决定了

38
00:01:15,100 --> 00:01:17,600
DOJO Core 里面的核应该长什么样子

39
00:01:17,600 --> 00:01:20,866
他们之间的通讯应该长什么样子

40
00:01:20,966 --> 00:01:23,066
下面呢我们看一下整体的一个概念

41
00:01:23,066 --> 00:01:25,100
今天我们的内容呢就是在这里面

42
00:01:25,266 --> 00:01:29,100
DOJO Core 里面的片上 SRAM 呢有 1.25MB

43
00:01:29,100 --> 00:01:31,300
整体的算力其实并不多

44
00:01:31,300 --> 00:01:33,533
但是呢我们的 DOJO 的 D1 呢

45
00:01:33,533 --> 00:01:36,866
有 354 个 DOJO Core 来去组成的

46
00:01:36,866 --> 00:01:38,400
为什么不是 360

47
00:01:38,400 --> 00:01:41,366
个呢是因为它有容错率

48
00:01:41,666 --> 00:01:43,400
接着呢我们看一下 DOJO Tile

49
00:01:43,400 --> 00:01:44,600
里面的训练芯片呢

50
00:01:44,600 --> 00:01:46,700
主要是由 5 乘以 5

51
00:01:46,700 --> 00:01:49,866
也就是 25 个 DOJO 的 D1 组成整个 Tile

52
00:01:50,300 --> 00:01:52,700
一个 Tile 呢对应的是一块 A100

53
00:01:52,700 --> 00:01:53,933
这么一块芯片

54
00:01:54,200 --> 00:01:56,566
六个 Tile 呢就组成了一个主机

55
00:01:56,866 --> 00:01:58,533
两个主机呢组成一个机柜

56
00:01:58,533 --> 00:02:01,666
每十个机柜呢就形成一个 ExaPOD

57
00:02:02,000 --> 00:02:03,466
这么一个组成的方式

58
00:02:03,800 --> 00:02:04,366
在这里面呢

59
00:02:04,366 --> 00:02:05,466
很有意思的一点就是

60
00:02:05,466 --> 00:02:08,266
DOJO Core 可以把它完全当成一个小型

61
00:02:08,266 --> 00:02:09,666
或者微型的 PC

62
00:02:09,700 --> 00:02:10,500
每个 DOJO Core 呢

63
00:02:10,500 --> 00:02:13,166
都可以自己独立的去执行他的任务

64
00:02:13,166 --> 00:02:15,100
不依赖于共享的 cache

65
00:02:15,100 --> 00:02:17,100
或者我们的寄存器

66
00:02:17,100 --> 00:02:19,466
整个 D1 呢作为 DOJO 的 Super Scalar 呢

67
00:02:19,466 --> 00:02:22,166
里面有 354 个 DOJO Core 嘛

68
00:02:22,166 --> 00:02:24,266
这意味着特斯拉可以使用更多的线程

69
00:02:24,266 --> 00:02:25,900
来驱动更多的指令

70
00:02:26,100 --> 00:02:30,000
通过 DOJO Core 来执行更多的计算任务

71
00:02:30,400 --> 00:02:32,966
下面呢我们来到了第一个内容

72
00:02:32,966 --> 00:02:35,666
就是 DOJO Core 的整体结构

73
00:02:36,300 --> 00:02:37,166
下面我们看一下

74
00:02:37,166 --> 00:02:40,466
左边的是 DOJO Core 的一些主要的参数

75
00:02:40,466 --> 00:02:42,800
右边的这个 DOJO Core 的核心的架构图

76
00:02:42,800 --> 00:02:43,466
我们可以看到

77
00:02:43,466 --> 00:02:45,500
数据格式是支持的非常的多的

78
00:02:45,500 --> 00:02:48,000
而位宽就 bit width 呢是 64b

79
00:02:48,266 --> 00:02:49,200
整体的 MM 呢

80
00:02:49,200 --> 00:02:51,666
我觉得最重要的是这个 MM 的单元

81
00:02:51,666 --> 00:02:54,900
也就是矩阵乘的单元有 4 路 8 乘以 8

82
00:02:55,366 --> 00:02:57,733
里面另外两个很重要的指标

83
00:02:57,733 --> 00:02:59,400
就是 SRAM 的 size

84
00:02:59,400 --> 00:03:00,700
是 1.25MB

85
00:03:00,733 --> 00:03:01,800
那 SRAM 的 rate 呢

86
00:03:01,800 --> 00:03:04,766
就是它的读写速率呢是 400GB 每秒

87
00:03:05,066 --> 00:03:06,366
写呢是 200GB 每秒

88
00:03:06,366 --> 00:03:08,466
也就是我们读的更多

89
00:03:08,466 --> 00:03:09,500
写的更少

90
00:03:09,533 --> 00:03:11,766
是因为我们需要大量的数据去读取

91
00:03:11,766 --> 00:03:12,766
然后写入

92
00:03:12,800 --> 00:03:14,400
计算完之后写入单一个

93
00:03:14,400 --> 00:03:15,800
或少量的数据

94
00:03:15,933 --> 00:03:16,733
那这里面呢

95
00:03:16,733 --> 00:03:19,166
最重要的是我刚才讲到的 SRAM size

96
00:03:19,333 --> 00:03:20,866
还有 MatMul

97
00:03:20,866 --> 00:03:23,066
就是我们的矩阵乘里面的大小

98
00:03:23,100 --> 00:03:25,066
另外的话 SMT 有四路

99
00:03:25,066 --> 00:03:26,800
这个呢也是比较重要的概念

100
00:03:27,133 --> 00:03:27,366
后面呢

101
00:03:27,366 --> 00:03:29,733
我们会详细的介绍这些参数的意义

102
00:03:29,733 --> 00:03:30,600
下面我们看一下

103
00:03:30,600 --> 00:03:33,400
整个 DOJO Core 的结构和特点呢

104
00:03:33,533 --> 00:03:35,133
实际上每个 DOJO Core 的核心呢

105
00:03:35,133 --> 00:03:36,933
就是这里面的 Execution Engine 呢

106
00:03:37,066 --> 00:03:39,066
实际上呢每个 DOJO Core 的核心呢

107
00:03:39,066 --> 00:03:41,800
它是具有 Scalar 和 Vector

108
00:03:41,800 --> 00:03:44,666
也就是向量和标量计算单元的能力

109
00:03:44,666 --> 00:03:46,266
而这里面 Scalar、Vector 呢

110
00:03:46,266 --> 00:03:48,600
它自己又具备整体的取指

111
00:03:48,600 --> 00:03:50,366
译码、执行的部件

112
00:03:50,466 --> 00:03:51,100
所以呢

113
00:03:51,100 --> 00:03:53,466
整个 DOJO Core 的核心呢是非常完善的

114
00:03:53,533 --> 00:03:56,000
不要看着 DOJO Core 的整体的晶体管很少

115
00:03:56,000 --> 00:03:57,066
或者部件很少呢

116
00:03:57,066 --> 00:03:58,666
就觉得它的作用不大

117
00:03:59,133 --> 00:04:00,600
接下来我们整体的去看看

118
00:04:00,600 --> 00:04:02,733
DOJO Core 的一个整体的结构

119
00:04:02,733 --> 00:04:05,400
首先呢它有三部分或者四部分组成哦

120
00:04:05,533 --> 00:04:07,666
第一部分呢就是 Front End 前端

121
00:04:07,700 --> 00:04:10,366
接着呢就是真正的执行引擎

122
00:04:10,366 --> 00:04:10,900
另外的话

123
00:04:10,900 --> 00:04:13,700
我们还有一个 SRAM 里面的 memory

124
00:04:13,733 --> 00:04:17,066
最后呢还有一个 NOC 的路由

125
00:04:17,066 --> 00:04:17,966
NOC 的 route

126
00:04:18,300 --> 00:04:21,533
相比 CPU 和 GPU 的控制部件呢它都更少

127
00:04:21,533 --> 00:04:24,166
就整个 DOJO Core 呢是非常的精简的

128
00:04:24,166 --> 00:04:26,400
但是呢这里面很核心的就是

129
00:04:26,400 --> 00:04:28,166
它有一个 MatMul 的计算单元

130
00:04:28,400 --> 00:04:30,533
类似于英伟达里面的 Tensor core

131
00:04:30,533 --> 00:04:31,666
矩阵计算单元

132
00:04:32,133 --> 00:04:34,666
不过呢 DOJO Core 确实非常非常的精简

133
00:04:34,700 --> 00:04:35,300
这里面呢

134
00:04:35,300 --> 00:04:35,866
可以看到

135
00:04:35,866 --> 00:04:38,133
他所有的部件还是非常的少的

136
00:04:38,266 --> 00:04:39,866
里面呢就取消了 Rename

137
00:04:39,866 --> 00:04:42,733
非常多的改善部件利用率的一些组件

138
00:04:42,733 --> 00:04:45,100
同时呢也不支持虚拟的内存

139
00:04:45,133 --> 00:04:45,766
所以这里面呢

140
00:04:45,766 --> 00:04:48,333
用的 SRAM 里面存的是实际的物理的地址

141
00:04:48,333 --> 00:04:49,400
这样做的意义呢

142
00:04:49,400 --> 00:04:51,966
就是希望能够减少控制部件

143
00:04:51,966 --> 00:04:53,066
所占用的面积

144
00:04:53,066 --> 00:04:56,733
把更多的面积留给我们这里面的 MatMul

145
00:04:56,800 --> 00:05:00,000
还有 ALU 那可能 MatMul 占的更多

146
00:05:00,000 --> 00:05:04,200
把更多的芯片的面积留给我们的计算

147
00:05:04,533 --> 00:05:05,000
另外一点呢

148
00:05:05,000 --> 00:05:07,866
就是提供了一个比较大的 SRAM

149
00:05:07,866 --> 00:05:09,200
所以呢我们可以看到

150
00:05:09,200 --> 00:05:11,366
整个 DOJO Core 的架构里面呢

151
00:05:11,400 --> 00:05:14,200
Matmal 就是我们的计算单元跟 SRAM

152
00:05:14,200 --> 00:05:15,000
存储单元

153
00:05:15,000 --> 00:05:17,866
决定了整个 DOJO Core 的计算的能效比

154
00:05:18,133 --> 00:05:19,366
既然谈到存储了

155
00:05:19,366 --> 00:05:21,566
也就是我们的 Memory Subsystem 呢

156
00:05:21,566 --> 00:05:23,400
呃有一点非常值得注意的

157
00:05:23,400 --> 00:05:25,166
就是 DOJO 上面运行的代码了

158
00:05:25,166 --> 00:05:27,466
实际上不能够直接访问我们的系统

159
00:05:27,466 --> 00:05:29,566
内存的整个 DOJO Core 里面的 Memory 呢

160
00:05:29,566 --> 00:05:32,100
只能访问自己的 SRAM 跟 Tensorcore

161
00:05:32,100 --> 00:05:33,733
跟英伟达的整体的架构呢

162
00:05:33,733 --> 00:05:35,266
是完全不一样的

163
00:05:35,266 --> 00:05:37,700
里面有非常多的共享的内存呢

164
00:05:37,700 --> 00:05:38,566
global memory 呢

165
00:05:38,566 --> 00:05:39,600
还有 local memory 呢

166
00:05:39,600 --> 00:05:40,766
这里面都没有

167
00:05:40,800 --> 00:05:42,333
只有一小部分的 SRAM

168
00:05:42,333 --> 00:05:45,500
能够给我们的 MatMul 进行计算和存储

169
00:05:45,800 --> 00:05:47,700
而整个 DOJO Core 的本地的 SRAM 呢

170
00:05:47,700 --> 00:05:50,066
完全是由我们的编译器去进行管理

171
00:05:50,066 --> 00:05:51,533
不能用作缓存

172
00:05:51,533 --> 00:05:53,266
这个概念是非常的重要

173
00:05:54,200 --> 00:05:55,266
了解完整体之后呢

174
00:05:55,266 --> 00:05:56,933
接下来我们来到了第二个内容

175
00:05:56,933 --> 00:05:59,300
DOJO Core 的前端处理

176
00:05:59,300 --> 00:06:00,566
我们的 Front End

177
00:06:01,533 --> 00:06:03,266
在整个 Front End 的前端模块

178
00:06:03,266 --> 00:06:05,766
也就是我们右边的架构图里面

179
00:06:05,766 --> 00:06:07,766
黄色的这一小部分呢

180
00:06:08,366 --> 00:06:10,366
一进来的第一个模块呢就是 BTB

181
00:06:10,366 --> 00:06:13,600
我们的分支目标缓冲区

182
00:06:13,900 --> 00:06:15,766
BTB 最重要的工作呢就是

183
00:06:15,766 --> 00:06:18,066
通过预测我们程序里面的分支的路径

184
00:06:18,066 --> 00:06:20,000
还有缓冲分支的使用的信息

185
00:06:20,000 --> 00:06:21,100
来减少我们流水线

186
00:06:21,100 --> 00:06:24,100
处理器里面的分支的性能的损失

187
00:06:24,933 --> 00:06:26,133
在 BTB 下面呢

188
00:06:26,133 --> 00:06:29,100
就有一个内容或者一个小的模块

189
00:06:29,100 --> 00:06:29,933
叫做 PC

190
00:06:30,266 --> 00:06:33,700
是计算机组成原理里面的程序计数器

191
00:06:34,000 --> 00:06:36,100
对程序指令呢进行计数的

192
00:06:36,100 --> 00:06:38,266
再往下呢就是 I-Cache 呢

193
00:06:38,266 --> 00:06:40,300
这个就是 L1 的指令缓存

194
00:06:40,566 --> 00:06:41,966
整个 L1 的指令缓存呢

195
00:06:41,966 --> 00:06:44,500
直接跟 DOJO Core 里面的 SRAM

196
00:06:44,500 --> 00:06:45,533
是直接相连的

197
00:06:45,533 --> 00:06:46,900
去获取计算

198
00:06:47,133 --> 00:06:49,100
接下来要进行计算的指令

199
00:06:49,133 --> 00:06:50,700
接着呢就有 Fetch buffer

200
00:06:50,700 --> 00:06:52,300
这里面呢就是取指器

201
00:06:52,300 --> 00:06:54,200
而这里面呢乘以 4 就是有 4 路

202
00:06:54,400 --> 00:06:56,500
最多呢可以容纳 8 条指令

203
00:06:56,533 --> 00:06:59,133
再往下的 decoder 呢就是我们的译码

204
00:06:59,766 --> 00:07:00,400
译码器呢

205
00:07:00,400 --> 00:07:03,466
从取值缓冲区里面呢获取到指令呢

206
00:07:03,466 --> 00:07:04,566
并对它进行译码呢

207
00:07:04,566 --> 00:07:06,333
根据每一条指令的要求呢

208
00:07:06,333 --> 00:07:08,400
分配所需要的执行的单元

209
00:07:08,933 --> 00:07:10,366
假设 Scalar 假设 Vector 的时候呢

210
00:07:10,366 --> 00:07:11,966
它就会对它进行分发

211
00:07:11,966 --> 00:07:13,100
分配主要的单元

212
00:07:13,100 --> 00:07:14,000
这里面呢

213
00:07:14,000 --> 00:07:15,266
上面的这些模块呢

214
00:07:15,266 --> 00:07:16,700
就是我们的前端的模块

215
00:07:16,733 --> 00:07:18,966
接下来就是线程的调度呢

216
00:07:18,966 --> 00:07:21,900
线程调度呢就是往下面的内容

217
00:07:21,900 --> 00:07:27,000
我们的 Scalar Scheduler 还有 SMT Vector schedule 了

218
00:07:27,000 --> 00:07:28,933
这里面呢都是做一些调度的

219
00:07:28,933 --> 00:07:31,600
分别指向我们的 Scalar 跟 Vector

220
00:07:31,600 --> 00:07:33,200
里面的具体的计算

221
00:07:33,300 --> 00:07:35,900
那在整个前端模块里面呢

222
00:07:36,366 --> 00:07:39,200
一旦 BTB 呢生成下一条指令的时候呢

223
00:07:39,366 --> 00:07:39,933
DOJO Core

224
00:07:39,933 --> 00:07:41,366
在每个时钟周期内呢

225
00:07:41,366 --> 00:07:43,666
就会从我们的 L1 Cache 里面呢

226
00:07:43,666 --> 00:07:44,800
去获取具体的指令

227
00:07:44,800 --> 00:07:45,700
给到我们的 buffer

228
00:07:45,700 --> 00:07:47,766
然后呢 decode 就会对我

229
00:07:47,766 --> 00:07:49,933
们的 buffer 呢进行译码整体的工作

230
00:07:49,933 --> 00:07:52,900
原理呢就是像刚才所讲到的

231
00:07:54,333 --> 00:07:54,866
接下来呢

232
00:07:54,866 --> 00:07:56,733
我们来到了第三个内容

233
00:07:56,733 --> 00:07:59,366
就是 DOJO 的执行引擎

234
00:07:59,366 --> 00:08:02,700
也就是里面最核心的计算单元

235
00:08:02,800 --> 00:08:03,400
计算单元呢

236
00:08:03,400 --> 00:08:06,566
就是我们下面绿色的这个模块

237
00:08:06,600 --> 00:08:08,466
针对 Scalar 和 Vector 呢

238
00:08:08,466 --> 00:08:11,000
都有四路的 SMT 啊

239
00:08:11,700 --> 00:08:14,333
下面呢我们来打开一下整个执行引擎

240
00:08:14,333 --> 00:08:16,866
也就是呃红色的这个模块

241
00:08:16,866 --> 00:08:18,366
还有紫色的这个模块

242
00:08:18,400 --> 00:08:20,266
具体的计算的方式

243
00:08:21,100 --> 00:08:21,866
下面我们看一下

244
00:08:21,866 --> 00:08:24,466
执行引擎里面的最重要的计算的单元

245
00:08:24,466 --> 00:08:26,133
也就是执行单元里面呢

246
00:08:26,133 --> 00:08:27,600
有两路的 ALU

247
00:08:27,600 --> 00:08:29,333
有两路的 AGU

248
00:08:29,400 --> 00:08:32,766
当然啦还有 512 位的 SIMD

249
00:08:32,900 --> 00:08:33,566
另外的话

250
00:08:33,566 --> 00:08:35,000
还有一个最重要最重要的

251
00:08:35,000 --> 00:08:37,866
就是里面 DOJO 最核心的 MatMul

252
00:08:37,866 --> 00:08:40,600
8*8*4 的这么一个矩阵的计算

253
00:08:40,900 --> 00:08:42,266
现在呢我们分开来看一下

254
00:08:42,266 --> 00:08:43,466
ALU 跟 AGU 呢

255
00:08:43,466 --> 00:08:46,566
主要是负责除了矩阵计算以外的

256
00:08:46,566 --> 00:08:49,133
一些少量的逻辑的运算

257
00:08:49,133 --> 00:08:51,966
那 AGU 呢主要是负责地址的生成单元

258
00:08:51,966 --> 00:08:53,166
而 ALU 啊

259
00:08:53,166 --> 00:08:54,900
大家不用我讲都知道啦

260
00:08:54,900 --> 00:08:57,133
主要负责简单的加减乘除这些工作

261
00:08:57,400 --> 00:08:59,800
另外的话我们看一下第二个内容

262
00:08:59,800 --> 00:09:01,666
或者第二个简单的执行模块

263
00:09:01,666 --> 00:09:03,200
就是 SIMD

264
00:09:03,300 --> 00:09:04,800
负责例如激活呀

265
00:09:04,800 --> 00:09:07,600
softmax 啊这些简单的计算的

266
00:09:07,800 --> 00:09:09,933
最后呢也是最核心的 MatMul

267
00:09:09,933 --> 00:09:12,966
我们的矩阵计算单元主要负责呃

268
00:09:12,966 --> 00:09:15,566
类似于现在大模型非常火的 Transformer

269
00:09:15,566 --> 00:09:17,133
包括以前呃

270
00:09:17,133 --> 00:09:18,933
比较火的一些卷积的

271
00:09:18,933 --> 00:09:21,066
核心的矩阵的计算

272
00:09:21,366 --> 00:09:22,900
在执行单元里面的整体加构

273
00:09:22,900 --> 00:09:24,266
里面很有意思的一点呢

274
00:09:24,266 --> 00:09:26,466
就是 DOJO 的分开两个

275
00:09:26,466 --> 00:09:28,400
第一个呢是 Scalar 的

276
00:09:28,400 --> 00:09:33,366
scheduler 一个呢是 Vector 的 scheduler

277
00:09:33,366 --> 00:09:34,500
那分开两个呢

278
00:09:34,500 --> 00:09:37,066
也就是两条执行的 pipeline

279
00:09:37,066 --> 00:09:38,933
一条呢是执行向量的计算

280
00:09:38,933 --> 00:09:41,333
一条呢是执行矩阵的计算

281
00:09:41,900 --> 00:09:43,300
一旦指令发起之后呢

282
00:09:43,300 --> 00:09:45,166
我们的数据就会从 SRAM 里面

283
00:09:45,166 --> 00:09:47,966
传送到我们具体的 Scalar Register 里面

284
00:09:47,966 --> 00:09:49,900
或者 Vector 的 Register 里面

285
00:09:49,933 --> 00:09:51,200
最后呢计算完之后呢

286
00:09:51,200 --> 00:09:52,700
就会把我们的数据呢

287
00:09:52,700 --> 00:09:55,766
回传到我们的 SRAM 上面

288
00:09:55,800 --> 00:09:56,900
整体的计算逻辑

289
00:09:56,900 --> 00:09:59,300
就是像我们刚才所描述的那样

290
00:09:59,566 --> 00:10:01,500
刚才讲到的数据的计算和存储呢

291
00:10:01,500 --> 00:10:03,500
就构成了我们整个 DOJO Core 里面

292
00:10:03,566 --> 00:10:04,300
最重要的类

293
00:10:04,300 --> 00:10:05,900
和数据搬运或者最重要类

294
00:10:05,900 --> 00:10:08,766
和 DOJO Core 里面的功耗的一大部分

295
00:10:09,700 --> 00:10:10,333
接下来呢

296
00:10:10,333 --> 00:10:13,666
ZOMI 就找到 google patent 里面

297
00:10:13,700 --> 00:10:15,700
特斯拉发的几篇专利

298
00:10:15,700 --> 00:10:16,800
那这几篇专利呢

299
00:10:16,800 --> 00:10:18,933
全部都是围绕着刚才讲到的

300
00:10:18,933 --> 00:10:20,200
矩阵的计算单元

301
00:10:20,400 --> 00:10:22,133
这个矩阵计算单元呢很有意思

302
00:10:22,133 --> 00:10:27,566
就是不管是横和竖都是一个 8*8 的矩阵

303
00:10:27,566 --> 00:10:28,700
而这里面的输入呢

304
00:10:28,700 --> 00:10:30,900
有两个一个是呢普通的 data 输入

305
00:10:30,900 --> 00:10:32,866
一个呢是我们的 Weight 的输入

306
00:10:32,866 --> 00:10:33,933
就权重的输入

307
00:10:34,400 --> 00:10:35,066
每个 DOJO Core 呢

308
00:10:35,066 --> 00:10:37,933
就包括 4 路的 8*8 的矩阵的计算

309
00:10:37,966 --> 00:10:38,900
在计算完之后呢

310
00:10:38,900 --> 00:10:40,900
就会有一个 post process Unit

311
00:10:40,900 --> 00:10:42,600
也就是后处理的单元

312
00:10:42,733 --> 00:10:45,766
专门去做一些累加呀或者激活的功能

313
00:10:46,366 --> 00:10:47,000
而这里面呢

314
00:10:47,000 --> 00:10:48,200
整个的计算流程呢

315
00:10:48,200 --> 00:10:50,933
是由左边里面的 control Unit

316
00:10:50,933 --> 00:10:52,600
去做一个总体的控制的

317
00:10:52,666 --> 00:10:54,000
那讲完这个之后呢

318
00:10:54,000 --> 00:10:56,133
我们来到了第四个内容

319
00:10:56,133 --> 00:10:58,166
也就是这个视频分享里面的

320
00:10:58,166 --> 00:10:59,266
最后一个内容了

321
00:10:59,266 --> 00:11:02,333
SRAM 跟内存之间的一个关系

322
00:11:02,333 --> 00:11:03,466
还有整个 DOJO Core 里面

323
00:11:03,466 --> 00:11:04,300
的一个关系

324
00:11:05,400 --> 00:11:07,766
今天呢我们稍微拖一拖堂

325
00:11:07,766 --> 00:11:10,133
然后把最后一个内容给他讲完了

326
00:11:10,200 --> 00:11:12,066
那在第四部分呢

327
00:11:12,066 --> 00:11:14,733
就是我们的 SRAM 跟我们的中间的路由嘛

328
00:11:14,733 --> 00:11:18,066
说白了路由其实为的就是传输数据

329
00:11:18,066 --> 00:11:21,200
而数据呢是存在 SRAM 里面的

330
00:11:21,400 --> 00:11:22,300
在 DOJO Core 里面呢

331
00:11:22,300 --> 00:11:24,133
每个节点也就是每个 DOJO Core 里面呢

332
00:11:24,133 --> 00:11:26,900
一共有 1.25MB 的 SRAM

333
00:11:26,933 --> 00:11:27,766
之所以说 DOJO Core

334
00:11:27,766 --> 00:11:29,700
是一个存算一体的架构呢

335
00:11:29,700 --> 00:11:31,366
是因为这里面把 SRAM 呢

336
00:11:31,366 --> 00:11:34,066
跟我们的 MatMul 里面的矩阵乘

337
00:11:34,200 --> 00:11:35,100
是放在一起

338
00:11:35,100 --> 00:11:38,066
最大限度的去减少我们数据的搬运

339
00:11:38,066 --> 00:11:40,066
也就是 memory bound 的这个限制

340
00:11:40,333 --> 00:11:41,933
有了这种架构的定义之后呢

341
00:11:41,933 --> 00:11:43,500
我们的应用程序啊

342
00:11:43,500 --> 00:11:45,966
主要是在本地的 SRAM 当中去工作的

343
00:11:45,966 --> 00:11:47,000
就是我们的计算项目

344
00:11:47,000 --> 00:11:48,466
都在 SRAM 里面去工作

345
00:11:48,666 --> 00:11:49,900
如果我们需要来自于 DDR

346
00:11:49,900 --> 00:11:50,933
或者高带宽显存

347
00:11:50,933 --> 00:11:52,366
HBM 里面的数据

348
00:11:52,400 --> 00:11:53,333
那这个时候呢

349
00:11:53,333 --> 00:11:56,500
必须要通过 DMA 进行一个操作和读录

350
00:11:56,500 --> 00:11:58,100
然后通过路由把我们的数据呢

351
00:11:58,100 --> 00:11:59,400
放在 SRAM 里面

352
00:12:00,000 --> 00:12:01,533
最后呢就通过列表解析引擎

353
00:12:01,533 --> 00:12:03,300
也就 List Parser engine

354
00:12:03,400 --> 00:12:05,733
来将我们不同的数据呢进行打包

355
00:12:05,733 --> 00:12:08,733
然后丢给我们的 decode 进行解码

356
00:12:08,733 --> 00:12:10,766
然后计算传输数据

357
00:12:10,766 --> 00:12:13,000
一系列刚才讲过的前端的工作了

358
00:12:13,900 --> 00:12:15,566
实际上呢存算一体这种架构呢

359
00:12:15,566 --> 00:12:19,133
为的就是让我们的时延更加的低

360
00:12:19,300 --> 00:12:22,300
因此呢 SRAM 的设计并非缓存

361
00:12:22,300 --> 00:12:24,533
而是在我们的主存跳过了一级缓存

362
00:12:24,533 --> 00:12:27,000
然后节省了很多芯片的功耗的面积

363
00:12:27,000 --> 00:12:28,766
我们传统样式计算机

364
00:12:28,766 --> 00:12:29,933
呃组成原理里面呢

365
00:12:29,933 --> 00:12:31,300
我们可能有 HBM

366
00:12:31,966 --> 00:12:32,766
有 L2 Cache，有 L1 Cache

367
00:12:32,766 --> 00:12:34,333
有 Register file 了

368
00:12:34,333 --> 00:12:35,133
一系列的工作

369
00:12:35,133 --> 00:12:37,366
也在我们的 GPU 里面给大家去讲过的

370
00:12:37,366 --> 00:12:39,200
那这里面呢都没有喽

371
00:12:39,733 --> 00:12:40,166
另外的话

372
00:12:40,166 --> 00:12:41,933
为了减少我们的芯片的面积呢

373
00:12:41,933 --> 00:12:42,600
DOJO 里面

374
00:12:42,600 --> 00:12:44,800
也没有虚拟内存的支持

375
00:12:44,800 --> 00:12:45,700
也没有 TLB

376
00:12:45,700 --> 00:12:47,533
各种列表各种便利的机制

377
00:12:47,766 --> 00:12:49,700
都把它这些都干掉

378
00:12:49,700 --> 00:12:51,900
剩下的就是我们刚才讲到了前端

379
00:12:51,900 --> 00:12:53,500
后端还有 SRAM

380
00:12:53,500 --> 00:12:56,933
另外还有一个 NOC 路由这么几个内容

381
00:12:56,933 --> 00:12:57,566
那接下来呢

382
00:12:57,566 --> 00:12:58,766
我们谈到 NOC 内容

383
00:12:58,766 --> 00:13:01,366
我们看一下 NOC Route 到底是个什么东西

384
00:13:01,700 --> 00:13:03,333
首先呢每个节点呢

385
00:13:03,333 --> 00:13:04,733
也就每个 DOJO Core

386
00:13:04,800 --> 00:13:07,600
都可以连接到一个 2D 的网络

387
00:13:07,600 --> 00:13:09,133
也就是导航导竖

388
00:13:09,133 --> 00:13:10,066
下一个内容呢

389
00:13:10,066 --> 00:13:12,200
就又是我们另外一个 DOJO Core 了

390
00:13:12,200 --> 00:13:14,966
那现在我们看一下整体的计算单元

391
00:13:14,966 --> 00:13:18,133
也就是我们的 Matmul 或者 Vector Scalar 里面

392
00:13:18,133 --> 00:13:18,600
跟 SRAM

393
00:13:18,600 --> 00:13:21,800
跟 NOC 之间的数据呢是怎么交互的

394
00:13:22,100 --> 00:13:24,066
可以通过指令呢去控制 NOC 路由

395
00:13:24,066 --> 00:13:25,333
直接把我们的数据呢

396
00:13:25,333 --> 00:13:26,300
搬运到

397
00:13:26,300 --> 00:13:29,266
或者搬出到我们的 SRAM 存储器里面

398
00:13:29,700 --> 00:13:31,666
在 SRAM 里面呢有两个内容啊

399
00:13:31,666 --> 00:13:33,166
刚才我们简单的讲了一个

400
00:13:33,166 --> 00:13:35,866
一个呢就是我们的列表解析引擎

401
00:13:35,866 --> 00:13:37,166
list praser engine

402
00:13:37,200 --> 00:13:38,133
另外呢一个呢

403
00:13:38,133 --> 00:13:41,700
就是我们的搜集引擎 data Gather engine

404
00:13:42,300 --> 00:13:43,366
那 List praser engine 呢

405
00:13:43,366 --> 00:13:46,333
主要是指我们的指令进行发送啊

406
00:13:46,333 --> 00:13:48,333
给到 decode 译码器

407
00:13:48,333 --> 00:13:49,766
那另外呢 gather engine 呢

408
00:13:49,766 --> 00:13:51,266
主要是控制我们的数据的

409
00:13:51,266 --> 00:13:52,733
把我们的数据呢进行打包

410
00:13:52,733 --> 00:13:54,933
然后呢给到距离计算单元更近的

411
00:13:54,933 --> 00:13:56,366
Register file 寄存器

412
00:13:56,366 --> 00:13:58,500
然后真正的进行计算之后回

413
00:13:58,500 --> 00:14:00,966
传我们的数据到列表解析引擎呢

414
00:14:00,966 --> 00:14:02,366
就 List praser engine 里面呢

415
00:14:02,366 --> 00:14:04,500
更多的是对我们的数据呢进行封装

416
00:14:04,500 --> 00:14:05,700
那那我们可以看到这里面呢

417
00:14:05,700 --> 00:14:07,133
concat operations list 呢

418
00:14:07,133 --> 00:14:09,566
就是把我们很多的一些数据呢

419
00:14:09,700 --> 00:14:10,766
啊指令呢

420
00:14:10,766 --> 00:14:12,000
进行一个打包

421
00:14:12,000 --> 00:14:12,933
更多是指令哦

422
00:14:13,266 --> 00:14:14,166
使得我们的计算呢

423
00:14:14,166 --> 00:14:15,700
在整个 DOJO Core 之间呢

424
00:14:15,700 --> 00:14:16,900
更加的高效

425
00:14:16,900 --> 00:14:18,300
那可能在一个 DOJO Core 里面呢

426
00:14:18,300 --> 00:14:18,966
执行一个指令

427
00:14:18,966 --> 00:14:20,533
在不同的 DOJO Core 里面呢

428
00:14:20,533 --> 00:14:22,000
执行不同的指令

429
00:14:22,000 --> 00:14:25,200
那不同的指令就带着不同的数据内容

430
00:14:25,600 --> 00:14:28,066
下面呢我们看一下整个 DOJO 的 D1

431
00:14:28,066 --> 00:14:28,866
DOJO

432
00:14:28,866 --> 00:14:31,100
是由 354 个 DOJO Core

433
00:14:31,100 --> 00:14:32,400
也就右边的这一小模块

434
00:14:32,400 --> 00:14:33,666
我们刚才讲了很多的

435
00:14:33,933 --> 00:14:35,333
而在整个 DOJO D1 里面呢

436
00:14:35,333 --> 00:14:36,500
大部分都是 DOJO Core

437
00:14:36,500 --> 00:14:36,933
这里面呢

438
00:14:36,933 --> 00:14:38,566
没有 DDR 没有 Pcie

439
00:14:38,700 --> 00:14:40,200
大部分都是裸芯片

440
00:14:40,200 --> 00:14:42,266
都是大量的计算单元

441
00:14:42,400 --> 00:14:43,800
而所有的 IO

442
00:14:43,800 --> 00:14:45,333
包括讲到的 DDR 啦

443
00:14:45,366 --> 00:14:46,800
HBM 呢 Pcie 呢

444
00:14:46,900 --> 00:14:48,800
都在外围的电路

445
00:14:48,800 --> 00:14:50,066
都在这上面

446
00:14:50,300 --> 00:14:52,600
那刚才我们讲到了简单的这个 5*5 呢

447
00:14:52,600 --> 00:14:53,900
就是一个 DOJO 的

448
00:14:53,900 --> 00:14:55,800
D1 在整个系统内存里面呢

449
00:14:55,800 --> 00:14:56,700
DOJO 的芯片呢

450
00:14:56,700 --> 00:14:59,133
是不直接连接在内存的

451
00:14:59,200 --> 00:14:59,866
而是装备到

452
00:14:59,866 --> 00:15:02,533
我们之前在第一个视频里面讲到的 HBM

453
00:15:02,533 --> 00:15:05,900
DIP 也就是上面的这个模块

454
00:15:06,600 --> 00:15:08,800
里面的主存或者显存呢

455
00:15:08,800 --> 00:15:11,766
就我们的 HBM 是在外围电路里面

456
00:15:11,766 --> 00:15:12,866
刚才讲到所有东西呢

457
00:15:12,866 --> 00:15:15,733
都是围绕着计算的和片内主存的

458
00:15:15,733 --> 00:15:16,766
那单个 DOJO 呢

459
00:15:16,766 --> 00:15:18,366
芯片是不能自给自足的

460
00:15:18,366 --> 00:15:19,366
因为它没有 DDR 啦

461
00:15:19,366 --> 00:15:20,500
没有 Pcie 呢

462
00:15:20,500 --> 00:15:21,200
啊因此呢

463
00:15:21,200 --> 00:15:22,733
刚才讲到的所有这些内容呢

464
00:15:22,733 --> 00:15:24,500
都是分布在整个 die

465
00:15:24,500 --> 00:15:25,166
就是 training die

466
00:15:25,166 --> 00:15:26,900
的一个呃外围

467
00:15:26,900 --> 00:15:29,500
那我们可以看到外围有很多这种接口

468
00:15:29,600 --> 00:15:33,366
9TB 每秒的一个 IO 接口和 PCIe 的接口

469
00:15:33,566 --> 00:15:35,000
哎我看了一下时间

470
00:15:35,000 --> 00:15:35,933
时间差不多了

471
00:15:36,066 --> 00:15:37,000
视频太长

472
00:15:37,000 --> 00:15:38,700
可能看的人就越来越少了

473
00:15:38,966 --> 00:15:40,500
今天呢只能聚焦 3 个内容

474
00:15:40,500 --> 00:15:41,933
跟大家一起去交流的

475
00:15:41,933 --> 00:15:42,500
那第一个呢

476
00:15:42,500 --> 00:15:44,533
就是 DOJO Core 的整体的架构里面呢

477
00:15:44,533 --> 00:15:46,866
就分为前端处理执行引擎

478
00:15:46,866 --> 00:15:47,933
还有 SRAM 内存

479
00:15:47,933 --> 00:15:51,066
最后还有一个 NOC 的路由

480
00:15:51,066 --> 00:15:52,533
那讲到前端的内容呢

481
00:15:52,533 --> 00:15:55,400
我们就把前端的几个处理的流程打开

482
00:15:55,400 --> 00:15:56,900
从 BTB 到我们的缓存

483
00:15:56,900 --> 00:15:59,300
到取码译码怎么去解决的

484
00:15:59,300 --> 00:16:01,733
整体流程 Pipeline 给大家打开了

485
00:16:01,866 --> 00:16:04,500
最后呢我们讲了 DOJO Core 的执行引擎

486
00:16:04,500 --> 00:16:06,500
主要是分开 Vector 跟 scalar

487
00:16:06,600 --> 00:16:07,400
所以计算里面呢

488
00:16:07,400 --> 00:16:08,866
最核心的就是特斯拉的

489
00:16:08,866 --> 00:16:10,533
发的那三篇专利

490
00:16:10,533 --> 00:16:12,533
大家有机会呢也可以去搜一下

491
00:16:12,866 --> 00:16:13,900
我们在下集内容呢

492
00:16:13,900 --> 00:16:15,500
再跟大家去展开 SRAM

493
00:16:15,500 --> 00:16:16,666
内存还有一些

494
00:16:16,666 --> 00:16:19,333
在整个 DOJO 的核心系统里面

495
00:16:19,333 --> 00:16:20,133
的一些问题

496
00:16:20,133 --> 00:16:22,533
之后就做一些简单的思考和回顾啦

497
00:16:22,600 --> 00:16:24,700
那今天的内容呢就到这里为止

498
00:16:24,700 --> 00:16:25,533
谢谢各位

