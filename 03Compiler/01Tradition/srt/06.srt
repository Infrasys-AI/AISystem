1
00:00:00,000 --> 00:00:04,000
[字幕生成：BLACK 字幕校对：志宇]

2
00:00:04,550 --> 00:00:07,000
嗨!大家好,我是 ZOMI

3
00:00:07,000 --> 00:00:09,720
今天来到 LLVM 架构和原理

4
00:00:09,720 --> 00:00:12,680
就是 LLVM 深度剖析的第二节内容

5
00:00:12,680 --> 00:00:14,120
在第二节内容里面

6
00:00:14,120 --> 00:00:18,360
主要去介绍 LLVM 的一个前端的优化过程

7
00:00:18,360 --> 00:00:20,800
和 LLVM 的中间优化过程

8
00:00:21,680 --> 00:00:22,560
在上一节里面

9
00:00:22,680 --> 00:00:24,720
其实讲到了 LLVM 的 IR

10
00:00:24,720 --> 00:00:28,400
贯穿了整个 LLVM 编译器的全生命周期

11
00:00:28,560 --> 00:00:31,760
里面的每一个箭头都有一个 IR 在流窜

12
00:00:31,760 --> 00:00:35,240
这个就是整体 LLVM 最重要的核心概念

13
00:00:35,240 --> 00:00:36,720
有了 LLVM IR 之后

14
00:00:36,720 --> 00:00:40,240
这并不意味着 LLVM 或者编译器的整个 pipeline

15
00:00:40,240 --> 00:00:42,240
都是使用一个单一的 IR

16
00:00:42,240 --> 00:00:43,880
而是在编译的不同阶段

17
00:00:43,880 --> 00:00:45,800
会采用不同的数据结构

18
00:00:45,800 --> 00:00:46,800
但总体来说

19
00:00:46,800 --> 00:00:49,280
还是会维护一个比较标准的 IR

20
00:00:49,280 --> 00:00:53,040
上面来具体的去看看 LLVM 的前端

21
00:00:53,720 --> 00:00:54,680
LLVM 的前端

22
00:00:54,680 --> 00:00:56,160
其实是把原代码

23
00:00:56,200 --> 00:00:58,400
也就是 C, C++, Python, Object C

24
00:00:58,400 --> 00:01:01,080
这些高级语言变为编译器的中间表示

25
00:01:01,080 --> 00:01:02,760
就是 LLVM 的 IR

26
00:01:02,760 --> 00:01:05,400
这个时候它处于代码生成之前

27
00:01:05,920 --> 00:01:06,880
代码生成之后

28
00:01:07,080 --> 00:01:08,720
就是跟目标所相关的

29
00:01:08,720 --> 00:01:10,320
跟硬件所相关的

30
00:01:10,320 --> 00:01:11,800
而代码生成之前

31
00:01:12,000 --> 00:01:14,000
是跟目标没关系的

32
00:01:14,000 --> 00:01:16,320
统一都会变成 LLVM IR

33
00:01:16,320 --> 00:01:18,600
所以在前端的最后一个环节

34
00:01:18,600 --> 00:01:20,280
是 IR 的生成

35
00:01:20,640 --> 00:01:21,320
一般来说

36
00:01:21,520 --> 00:01:24,720
前端都会处理一组相同或者相类似的语言

37
00:01:24,720 --> 00:01:27,160
所以 Cling 在美语里面读 Cling

38
00:01:27,160 --> 00:01:28,720
在英语里面读 Cline

39
00:01:29,480 --> 00:01:32,360
这个 Kling 主要是处理 C, C++, Object C

40
00:01:32,360 --> 00:01:34,640
这一类相类似 C 的语言

41
00:01:35,080 --> 00:01:37,360
前端主要是经历了三个步骤

42
00:01:37,360 --> 00:01:38,360
一个是词法分析

43
00:01:38,360 --> 00:01:39,280
一个是语法分析

44
00:01:39,280 --> 00:01:40,880
另外一个是语义分析

45
00:01:40,880 --> 00:01:42,720
让 IR 生成这个是最通用的

46
00:01:42,720 --> 00:01:44,840
基本上 LLVM 每一个对接的前端

47
00:01:44,840 --> 00:01:45,840
都会有一个

48
00:01:46,000 --> 00:01:48,480
所以后面会深入的去看看词法分析

49
00:01:48,480 --> 00:01:49,240
语法分析

50
00:01:49,240 --> 00:01:50,640
还有语义分析

51
00:01:51,280 --> 00:01:52,840
编译器前端的第一个步骤

52
00:01:52,960 --> 00:01:54,760
就做词法分析

53
00:01:54,760 --> 00:01:55,840
Let's go analyze

54
00:01:55,840 --> 00:01:58,520
它的输入是高级语言的文本

55
00:01:58,520 --> 00:02:00,240
这里面词法分析

56
00:02:00,240 --> 00:02:01,600
主要是将语言的结构

57
00:02:01,720 --> 00:02:03,800
分为一组单词和标记

58
00:02:04,040 --> 00:02:05,840
把一些空白注释

59
00:02:05,960 --> 00:02:08,240
还有字表符等其他没有用的东西

60
00:02:08,480 --> 00:02:10,120
先把它删除掉

61
00:02:10,120 --> 00:02:12,520
然后变成一组单词和标记

62
00:02:13,240 --> 00:02:16,360
下面以最简单的 Hello World 为例子

63
00:02:16,480 --> 00:02:18,040
这段代码比较简单

64
00:02:18,040 --> 00:02:19,560
定义了一个红 Hello World

65
00:02:19,560 --> 00:02:20,840
然后把它打印出来

66
00:02:20,840 --> 00:02:21,800
返回 0

67
00:02:22,200 --> 00:02:24,680
这里面所指的每个单词或者标记

68
00:02:24,840 --> 00:02:26,480
都必须属于高级语言

69
00:02:26,480 --> 00:02:28,320
或者 C 语言的一个子集

70
00:02:28,320 --> 00:02:29,640
语言里面的保留字

71
00:02:29,760 --> 00:02:31,760
就会变成编译器的内部表示

72
00:02:32,000 --> 00:02:33,600
也就是 IR

73
00:02:33,600 --> 00:02:34,880
在词法分析的第一步

74
00:02:35,000 --> 00:02:35,880
可以看到

75
00:02:35,880 --> 00:02:37,680
编译器把每一个符号

76
00:02:37,680 --> 00:02:38,640
每一个括号

77
00:02:38,640 --> 00:02:39,800
每一个字符

78
00:02:39,800 --> 00:02:41,440
全都分解出来

79
00:02:41,440 --> 00:02:44,560
还记录了每一个字符出现的一个 location

80
00:02:44,560 --> 00:02:46,240
Hello.c 里面的第 6 行

81
00:02:46,240 --> 00:02:47,480
第 12 个字符

82
00:02:48,400 --> 00:02:49,720
这么做最重要的目的

83
00:02:49,840 --> 00:02:51,960
就是将术语的高级语言

84
00:02:52,840 --> 00:02:55,600
切分成一个个语言的元组

85
00:02:55,960 --> 00:02:57,600
方便下一个步骤的分析

86
00:02:57,600 --> 00:02:58,480
那现在来看看

87
00:02:58,480 --> 00:03:00,120
第二个步骤做的哪些工作

88
00:03:00,160 --> 00:03:02,480
第二个步骤叫做语法分析

89
00:03:03,320 --> 00:03:04,840
Synthetical Analyze

90
00:03:05,880 --> 00:03:07,600
在词法分析标记完

91
00:03:07,600 --> 00:03:08,880
整个原代码之后

92
00:03:09,080 --> 00:03:11,040
语法分析就开始工作了

93
00:03:11,160 --> 00:03:13,360
这里面以表达式语句

94
00:03:13,360 --> 00:03:15,400
函数等不同的方式

95
00:03:15,400 --> 00:03:17,280
去进行一个分组的标记

96
00:03:17,480 --> 00:03:18,680
分组标记完之后

97
00:03:18,840 --> 00:03:20,400
就是方便语法分析器

98
00:03:20,600 --> 00:03:21,920
去检查每一组

99
00:03:21,920 --> 00:03:23,360
是否有真正的物理意义

100
00:03:23,360 --> 00:03:24,680
而这里面的物理意义

101
00:03:24,880 --> 00:03:27,040
主要是讲它这行代码写的对

102
00:03:27,040 --> 00:03:27,880
还是没对

103
00:03:28,600 --> 00:03:30,320
重点就是考虑代码的

104
00:03:30,320 --> 00:03:31,600
整个物理的布局

105
00:03:31,600 --> 00:03:33,320
可以看到这里面有一级二级

106
00:03:33,320 --> 00:03:34,840
然后一层层地加

107
00:03:34,840 --> 00:03:37,200
然后整体类似一个数的概念

108
00:03:37,240 --> 00:03:39,240
这种方式就是语法分析里面

109
00:03:39,240 --> 00:03:41,080
去考虑代码的物理布局

110
00:03:42,240 --> 00:03:43,120
但是到这一步

111
00:03:43,240 --> 00:03:44,440
其实并没有去分析

112
00:03:44,440 --> 00:03:46,000
代码的整体的含义

113
00:03:46,000 --> 00:03:48,280
通俗点来说就是语法分析器

114
00:03:48,280 --> 00:03:50,680
并不管这段代码是干什么了

115
00:03:51,040 --> 00:03:52,720
只考虑这段代码是否正确

116
00:03:52,720 --> 00:03:54,040
并且输出语法树

117
00:03:54,400 --> 00:03:55,960
接收词法分析器标数的

118
00:03:55,960 --> 00:03:57,160
token 作为一个输入

119
00:03:57,160 --> 00:03:58,760
然后输出语法树

120
00:03:58,760 --> 00:04:00,040
也就是 AST

121
00:04:00,160 --> 00:04:01,560
图中的这段表示

122
00:04:01,720 --> 00:04:02,960
只是方便去看

123
00:04:02,960 --> 00:04:04,440
实际上代码语法树

124
00:04:04,840 --> 00:04:05,800
里面每一个节点

125
00:04:05,920 --> 00:04:07,280
都是有自己的定义的

126
00:04:08,160 --> 00:04:10,160
第三步就是语义分析

127
00:04:10,160 --> 00:04:11,560
Semantic Analyzed

128
00:04:11,560 --> 00:04:12,920
刚才语法分析

129
00:04:12,920 --> 00:04:14,280
只是分析我这个句子

130
00:04:14,280 --> 00:04:15,040
有没有错

131
00:04:15,040 --> 00:04:15,920
这一行代码

132
00:04:15,920 --> 00:04:17,640
有没有写错物理意义

133
00:04:18,160 --> 00:04:19,640
下面以第五行

134
00:04:19,640 --> 00:04:21,480
第六行代码作为例子

135
00:04:21,480 --> 00:04:22,760
一开始定义了一个

136
00:04:22,760 --> 00:04:24,000
int a 四维的数组

137
00:04:24,000 --> 00:04:25,080
接着我在第六行

138
00:04:25,080 --> 00:04:27,560
再定义一个 int a 五维的数组

139
00:04:27,560 --> 00:04:29,640
然后去执行 clean-c hello

140
00:04:29,640 --> 00:04:30,360
这个时候

141
00:04:30,960 --> 00:04:31,920
结果会看到

142
00:04:31,920 --> 00:04:32,680
编译器

143
00:04:32,680 --> 00:04:33,800
会爆出一个错误

144
00:04:33,800 --> 00:04:35,120
告诉 a

145
00:04:35,120 --> 00:04:36,640
其实已经定义好了

146
00:04:36,640 --> 00:04:38,360
你定义的位置是在这里面的

147
00:04:38,360 --> 00:04:40,840
这里面就出现了一个错误

148
00:04:41,280 --> 00:04:43,320
从这个简单的例子可以看到

149
00:04:43,600 --> 00:04:44,160
语义分析

150
00:04:44,400 --> 00:04:46,360
就是借助高级语言的符号表

151
00:04:46,360 --> 00:04:47,600
去检查代码

152
00:04:47,760 --> 00:04:50,240
有没有违背高级语言的类型

153
00:04:50,600 --> 00:04:51,600
有没有语法错误

154
00:04:52,280 --> 00:04:53,760
最后一步就是生成

155
00:04:53,760 --> 00:04:54,720
LLVM IR

156
00:04:54,720 --> 00:04:57,360
然后进入 LLVM 的优化层

157
00:04:57,920 --> 00:04:59,200
了解 LLVM 的优化层

158
00:04:59,360 --> 00:05:01,040
其实并不会去展开

159
00:05:01,040 --> 00:05:02,040
讲每一个 pass

160
00:05:02,040 --> 00:05:03,320
具体做了哪些工作

161
00:05:03,320 --> 00:05:04,960
针对 C 语言或者 C++语言

162
00:05:04,960 --> 00:05:06,600
对 C 这些不同的语言

163
00:05:06,600 --> 00:05:09,240
做了哪些不同的优化的方式

164
00:05:09,520 --> 00:05:10,480
或者对 IR

165
00:05:10,480 --> 00:05:11,720
做了哪些独特的优化

166
00:05:12,360 --> 00:05:13,720
而是去了解优化层的

167
00:05:13,720 --> 00:05:14,360
这个 Pipeline

168
00:05:14,360 --> 00:05:15,800
具体是怎么工作的

169
00:05:16,320 --> 00:05:18,320
LLVM 优化层的输是

170
00:05:18,320 --> 00:05:19,200
LLVM IR

171
00:05:19,200 --> 00:05:21,480
输出也是 LLVM 的 IR

172
00:05:21,720 --> 00:05:23,040
这里面只是一个示例

173
00:05:23,040 --> 00:05:24,440
实际上它的输是一个

174
00:05:24,440 --> 00:05:25,440
ASG 的语法树

175
00:05:25,440 --> 00:05:26,480
然后变成一个 IR

176
00:05:26,760 --> 00:05:28,080
它的输出是一个 IR

177
00:05:28,080 --> 00:05:29,680
但是输给指定的时候

178
00:05:30,040 --> 00:05:31,760
已经变成一个 DAG 的图了

179
00:05:32,000 --> 00:05:33,320
在上一节课里面

180
00:05:33,320 --> 00:05:35,560
其实已经简单的介绍了一下

181
00:05:35,840 --> 00:05:37,960
为什么它的输输出比较特别

182
00:05:38,200 --> 00:05:38,960
现在来看一看

183
00:05:38,960 --> 00:05:40,920
优化层做了哪些工作

184
00:05:41,800 --> 00:05:42,760
优化层里面的

185
00:05:42,760 --> 00:05:45,160
每一种优化的方式叫做 Pass

186
00:05:45,600 --> 00:05:46,440
Pass 这个概念

187
00:05:46,560 --> 00:05:47,800
其实在第一节

188
00:05:47,800 --> 00:05:48,720
分享的内容里面

189
00:05:48,720 --> 00:05:50,000
给大家汇报过

190
00:05:50,000 --> 00:05:51,960
它就是对 LLVM IR

191
00:05:51,960 --> 00:05:53,040
或者对程序

192
00:05:53,040 --> 00:05:54,040
做一次变逆

193
00:05:54,240 --> 00:05:55,800
这一次变逆的叫做 Pass

194
00:05:56,640 --> 00:05:57,520
而优化层里面

195
00:05:57,680 --> 00:05:59,000
又分为分析的 Pass

196
00:05:59,000 --> 00:06:00,320
和转换的 Pass

197
00:06:00,320 --> 00:06:01,200
有两种 Pass

198
00:06:01,800 --> 00:06:02,720
有两种的 Pass

199
00:06:02,720 --> 00:06:04,040
而这两种不同的 Pass

200
00:06:04,240 --> 00:06:05,440
负责不同的工作

201
00:06:05,440 --> 00:06:06,320
现在来看

202
00:06:06,320 --> 00:06:07,880
分析的 Pass 做什么

203
00:06:07,880 --> 00:06:08,640
分析的 Pass

204
00:06:08,800 --> 00:06:09,760
主要是发掘一些

205
00:06:09,760 --> 00:06:11,760
性能和优化的机会点

206
00:06:11,760 --> 00:06:13,560
就是它只做分析

207
00:06:13,600 --> 00:06:16,040
它不做具体的转换和生成

208
00:06:16,040 --> 00:06:17,600
它也不做具体的工作

209
00:06:17,600 --> 00:06:18,600
而具体的工作

210
00:06:18,720 --> 00:06:21,120
留给转换的 Pass 来做

211
00:06:21,320 --> 00:06:22,080
转换的 Pass

212
00:06:22,200 --> 00:06:24,520
就会生成所必要的数据结构

213
00:06:24,720 --> 00:06:25,680
这个数据结构

214
00:06:25,840 --> 00:06:27,360
也叫做 IR

215
00:06:27,600 --> 00:06:29,440
它是基于 LLVM IR 之上

216
00:06:29,440 --> 00:06:31,400
定制的一个具体的数据结构

217
00:06:31,400 --> 00:06:33,480
或者它特有的一个 IR 形式

218
00:06:33,840 --> 00:06:35,000
为后续的转换 Pass

219
00:06:35,000 --> 00:06:36,760
或分析 Pass 所使用到的

220
00:06:37,360 --> 00:06:39,480
现在执行下面的这条命令

221
00:06:39,480 --> 00:06:40,000
OPT

222
00:06:40,200 --> 00:06:41,680
OPT 就是 Optimization

223
00:06:41,880 --> 00:06:43,680
是 LLVM 里面的一个工具

224
00:06:43,680 --> 00:06:44,880
然后 hello.bc

225
00:06:44,880 --> 00:06:48,040
bc 就是 LLVM 的 IR 的一种呈现方式

226
00:06:48,040 --> 00:06:48,960
然后 instruction

227
00:06:48,960 --> 00:06:50,040
hello.bc

228
00:06:50,040 --> 00:06:51,960
然后把 Stata 打出来

229
00:06:51,960 --> 00:06:54,760
然后就打印出图了

230
00:06:54,960 --> 00:06:56,360
可以看到图里面

231
00:06:56,480 --> 00:06:57,920
有非常多的 Pass

232
00:06:58,200 --> 00:06:59,320
实际上这个图

233
00:06:59,320 --> 00:07:00,240
还是执行了

234
00:07:00,240 --> 00:07:02,280
刚才很简单的代码

235
00:07:02,480 --> 00:07:04,080
代码呈现出来的结果

236
00:07:04,600 --> 00:07:05,880
运行了不同的 Pass

237
00:07:05,880 --> 00:07:07,600
具体其实我也不知道

238
00:07:07,600 --> 00:07:09,400
这些 Pass 做了哪些工作

239
00:07:09,560 --> 00:07:10,680
来看看这些 Pass

240
00:07:10,880 --> 00:07:11,880
做了哪些工作

241
00:07:12,840 --> 00:07:14,760
下面打开这条链接

242
00:07:16,040 --> 00:07:17,320
这条链接里面打开了

243
00:07:17,320 --> 00:07:20,120
就是 LLVM Pass 里面的一个介绍

244
00:07:20,120 --> 00:07:21,760
里面就分为 Analyze Pass

245
00:07:21,760 --> 00:07:23,160
还有 Transform Pass

246
00:07:23,520 --> 00:07:25,360
Analyze Pass 有非常多

247
00:07:25,360 --> 00:07:27,680
主要是做一些分析性的工作

248
00:07:27,680 --> 00:07:28,760
而 Transform Pass

249
00:07:28,960 --> 00:07:30,800
就是做一些实际的转换

250
00:07:31,160 --> 00:07:33,920
以下面 ADCE 作为例子

251
00:07:33,920 --> 00:07:35,720
积极的死代码消除

252
00:07:36,000 --> 00:07:38,040
虽然我不知道积极的死代码消除

253
00:07:38,040 --> 00:07:38,760
代表是什么

254
00:07:38,760 --> 00:07:40,200
但是这里面就描述了

255
00:07:40,200 --> 00:07:42,920
这个 Pass 跟 DEC 非常类似

256
00:07:42,920 --> 00:07:44,880
DEC 就是死代码消除

257
00:07:44,880 --> 00:07:46,840
就是把一些没有用的代码

258
00:07:46,840 --> 00:07:47,680
把它删掉

259
00:07:47,960 --> 00:07:49,360
什么为之没有用的代码

260
00:07:49,560 --> 00:07:51,400
举一个具体的例子

261
00:07:52,400 --> 00:07:53,720
在 Mate 函数里面

262
00:07:53,920 --> 00:07:56,800
我声明一个 int b 等于 1

263
00:07:57,080 --> 00:07:58,800
然后 int c 等于 0

264
00:07:59,240 --> 00:08:01,000
最后我返回的是一个 0

265
00:08:01,280 --> 00:08:03,240
在程序去执行这段代码的时候

266
00:08:03,360 --> 00:08:04,840
其实有用的信息就是

267
00:08:04,840 --> 00:08:05,960
print hello world

268
00:08:06,200 --> 00:08:07,520
然后返回一个 0

269
00:08:07,760 --> 00:08:09,800
中间的两个定义 int b

270
00:08:09,800 --> 00:08:10,440
int c

271
00:08:10,440 --> 00:08:12,760
它只是开辟了一个内存的空间

272
00:08:12,760 --> 00:08:14,320
然后声明了一个变量

273
00:08:14,320 --> 00:08:15,320
做了一个复制

274
00:08:15,320 --> 00:08:16,840
实际上它对于这个程序

275
00:08:17,120 --> 00:08:18,360
是没有任何作用的

276
00:08:18,360 --> 00:08:20,120
这种在变异的过程当中

277
00:08:20,120 --> 00:08:21,560
就会把这段删掉

278
00:08:21,560 --> 00:08:23,920
这种工作叫做死代码消除

279
00:08:24,720 --> 00:08:27,400
也就是转换 Pass DEC 所做的工作

280
00:08:27,400 --> 00:08:28,440
而做这个工作

281
00:08:28,560 --> 00:08:30,320
不是基于刚才所演示的

282
00:08:30,320 --> 00:08:32,120
实际的高级语言的代码去做的

283
00:08:32,120 --> 00:08:34,480
而是通过 LLVM IR 去做的

284
00:08:34,840 --> 00:08:36,280
因为死代码消除

285
00:08:36,280 --> 00:08:38,200
它是一个非常通用的需求

286
00:08:38,200 --> 00:08:40,000
包括 Java Python C C++

287
00:08:40,000 --> 00:08:42,720
Object C 都有同样类型的需求

288
00:08:43,040 --> 00:08:44,320
再举一个例子

289
00:08:44,320 --> 00:08:47,160
叫做 merge duplicate global constants

290
00:08:47,440 --> 00:08:50,080
它的意思是将重复的全局常量

291
00:08:50,080 --> 00:08:51,960
合并到一个共享的常量里面

292
00:08:52,320 --> 00:08:53,120
点开看一看

293
00:08:53,440 --> 00:08:54,440
这里面就说了

294
00:08:54,440 --> 00:08:56,960
这一个 Pass 是非常有用的

295
00:08:56,960 --> 00:08:58,440
因为在有一些 Pass 里面

296
00:08:58,560 --> 00:09:00,680
插了非常多的变量

297
00:09:00,680 --> 00:09:02,200
然后到程序里面

298
00:09:02,520 --> 00:09:04,800
所以编辑会对这些常量进行优化

299
00:09:05,480 --> 00:09:05,920
在这里面

300
00:09:06,080 --> 00:09:07,680
其实我之前曾经写过

301
00:09:07,680 --> 00:09:08,600
很多不同的 Pass

302
00:09:08,600 --> 00:09:10,040
在 AI 编译器里面

303
00:09:10,320 --> 00:09:11,160
大家不要觉得

304
00:09:11,160 --> 00:09:12,840
这是一个很高大上的动作

305
00:09:12,840 --> 00:09:15,760
其实这个是基于规则去写的代码

306
00:09:16,360 --> 00:09:17,520
在写 Pass 的时候

307
00:09:17,640 --> 00:09:18,480
其实很简单

308
00:09:18,720 --> 00:09:21,160
我已经知道 Pass 具体做什么工作了

309
00:09:21,160 --> 00:09:23,280
我知道它要把所有的全局变量

310
00:09:23,280 --> 00:09:25,600
都合并到一个共享的常量里面

311
00:09:25,600 --> 00:09:27,720
这个时候根据 LLVM 的 IR

312
00:09:27,720 --> 00:09:30,960
去编译或者 forLLVM IR

313
00:09:30,960 --> 00:09:33,320
然后找到一些全局的变量

314
00:09:33,360 --> 00:09:35,440
把这些全局变量都记录下来

315
00:09:35,440 --> 00:09:37,280
然后通过上一节介绍的

316
00:09:37,280 --> 00:09:38,880
LLVM 的内存的模式

317
00:09:38,880 --> 00:09:40,320
去控制 LLVM

318
00:09:40,320 --> 00:09:42,600
去把重复的全局常量去删掉

319
00:09:42,600 --> 00:09:44,400
只留下一个共享的常量

320
00:09:44,400 --> 00:09:45,840
所以这里面是很表达的

321
00:09:45,840 --> 00:09:48,000
就是写一个 Pass 没有这么难

322
00:09:48,000 --> 00:09:49,000
只是需要知道

323
00:09:49,000 --> 00:09:50,560
这个 Pass 具体做哪些

324
00:09:50,560 --> 00:09:52,680
知道优化器有多少个 Pass

325
00:09:52,960 --> 00:09:54,280
想进一步去了解的同学

326
00:09:54,400 --> 00:09:55,920
就可以打开这条链接

327
00:09:55,920 --> 00:09:57,760
去看看 LLVM 里面的 Pass

328
00:09:57,760 --> 00:09:59,080
具体有哪些工作

329
00:09:59,440 --> 00:10:01,680
另外想深入到 Pass 具体是怎么写的

330
00:10:01,680 --> 00:10:02,960
可以深入到代码

331
00:10:02,960 --> 00:10:04,400
因为 LLVM 是开源的

332
00:10:04,400 --> 00:10:05,760
去看看每一个 Pass

333
00:10:05,760 --> 00:10:07,280
具体是怎么实现的

334
00:10:08,160 --> 00:10:09,520
下面来理一理

335
00:10:09,520 --> 00:10:11,360
Pass 之间的一个关系

336
00:10:11,360 --> 00:10:13,160
在转换的 Pass 和分析的 Pass

337
00:10:13,320 --> 00:10:14,520
有两种依赖关系

338
00:10:14,520 --> 00:10:15,960
一种是显性的依赖

339
00:10:15,960 --> 00:10:17,400
一种是隐性的依赖

340
00:10:17,400 --> 00:10:19,560
那什么为之显性的依赖呢

341
00:10:19,840 --> 00:10:21,960
刚才讲过转换的 Pass

342
00:10:22,120 --> 00:10:23,480
是实际工作的

343
00:10:23,480 --> 00:10:24,560
但是它工作之前

344
00:10:24,720 --> 00:10:26,080
它依赖于一种分析

345
00:10:26,080 --> 00:10:28,320
就是你要把分析的结果告诉我

346
00:10:28,320 --> 00:10:29,960
然后我再做转换

347
00:10:30,200 --> 00:10:32,320
以合并全局常量为例子

348
00:10:32,880 --> 00:10:33,680
分析的 Pass

349
00:10:33,880 --> 00:10:36,720
去分析有多少重复的全局常量

350
00:10:36,920 --> 00:10:37,760
转换的 Pass

351
00:10:37,920 --> 00:10:39,600
就是做合并的工作

352
00:10:39,800 --> 00:10:41,320
所以说转换的 Pass 之前

353
00:10:41,440 --> 00:10:42,920
它需要一个分析的 Pass

354
00:10:42,920 --> 00:10:44,160
而 Pass 的管理器

355
00:10:44,160 --> 00:10:45,080
就是 Pass Manager

356
00:10:45,360 --> 00:10:47,680
就会自动的去安排所依赖的 Pass

357
00:10:47,920 --> 00:10:48,840
它怎么自动安排

358
00:10:48,960 --> 00:10:51,040
还是根据代码去实现的

359
00:10:51,040 --> 00:10:52,880
这里面有个 Domain Tree

360
00:10:52,880 --> 00:10:54,880
然后 getAnalyzeDomainTree

361
00:10:54,880 --> 00:10:56,280
前面就声明了

362
00:10:56,280 --> 00:10:58,000
我需要使用哪一种函数

363
00:10:58,000 --> 00:10:59,280
使用哪一种分析

364
00:10:59,480 --> 00:11:01,640
第二种就是隐性的依赖

365
00:11:01,880 --> 00:11:03,960
在转换或者分析的 Pass 之前

366
00:11:04,120 --> 00:11:06,200
它对上下文是有依赖关系的

367
00:11:06,400 --> 00:11:07,400
我做转换之前

368
00:11:07,520 --> 00:11:08,960
我没有显现的高速程序

369
00:11:08,960 --> 00:11:10,320
我现在需要哪些

370
00:11:10,360 --> 00:11:12,120
这个时候就需要手动的

371
00:11:12,120 --> 00:11:13,600
去正确的把这些 Pass

372
00:11:13,640 --> 00:11:15,440
插到正确的位置里面

373
00:11:15,760 --> 00:11:17,640
最后就是 Pass 的 API

374
00:11:17,640 --> 00:11:18,840
在 Pass 实现的时候

375
00:11:18,960 --> 00:11:21,120
它其实是分层级分力度的

376
00:11:21,320 --> 00:11:23,640
如果对整个模块进行处理

377
00:11:23,760 --> 00:11:24,960
有 Model 的 Pass

378
00:11:25,000 --> 00:11:26,720
对一个函数进行处理

379
00:11:26,720 --> 00:11:28,040
有 Function 的 Pass

380
00:11:28,080 --> 00:11:29,760
如果只对某几条指令

381
00:11:29,760 --> 00:11:31,120
某几个语句进行处理

382
00:11:31,320 --> 00:11:32,840
这里面有 Basic Boxed Pass

383
00:11:33,040 --> 00:11:34,320
分开不同力度的 Pass

384
00:11:34,480 --> 00:11:36,880
就是为了让更好地去选择

385
00:11:36,880 --> 00:11:38,720
所处理的对象处理的欲

386
00:11:39,280 --> 00:11:40,960
卷得不行了

387
00:11:40,960 --> 00:11:42,360
记得一键三连加关注

388
00:11:42,760 --> 00:11:44,120
所有的内容都会开源

389
00:11:44,120 --> 00:11:45,880
在下面这条链接里面

390
00:11:46,320 --> 00:11:47,200
白了个拜

