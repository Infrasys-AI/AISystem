1
00:00:00,000 --> 00:00:04,680
[字幕生成：BLACK 字幕校对：志宇]

2
00:00:06,680 --> 00:00:06,680
嗨，我是 ZOMI

3
00:00:06,680 --> 00:00:08,800
今天还是延续上一节课的内容

4
00:00:08,800 --> 00:00:10,520
LLVM 的架构和原理

5
00:00:10,520 --> 00:00:13,920
其实我没有想到看编译系的人还会比真的看

6
00:00:13,920 --> 00:00:17,120
AI 核心技术相关的分享视频没有几个人看

7
00:00:17,120 --> 00:00:20,960
但是我讲关于编译系的内容反倒有很多人去看

8
00:00:25,560 --> 00:00:26,720
在上一节的内容里面

9
00:00:26,720 --> 00:00:29,520
其实已经讲了 LLVM 的一个项目的具体的发展

10
00:00:29,520 --> 00:00:32,640
还有 LLVM 的具体的设计和它的一个基本的架构

11
00:00:32,640 --> 00:00:33,800
那在这一节课里面

12
00:00:33,800 --> 00:00:35,800
会讲讲 LLVM 的一个中间表达

13
00:00:35,800 --> 00:00:38,240
还有 LLVM 的前端的详细过程

14
00:00:38,240 --> 00:00:39,920
LLVM 的中间的优化流程

15
00:00:39,920 --> 00:00:41,440
还有 LLVM 的后端

16
00:00:41,440 --> 00:00:44,720
最后还会去介绍一下基于 LLVM 的项目

17
00:00:44,720 --> 00:00:47,160
但是如果这个视频过长的话

18
00:00:47,160 --> 00:00:48,680
我会把它剪成两段

19
00:00:48,680 --> 00:00:50,640
就是希望保持每一段有十几分钟

20
00:00:50,640 --> 00:00:51,480
然后看着不累

21
00:00:56,680 --> 00:00:59,080
下面来到 LLVM 的一个整体的架构图

22
00:00:59,080 --> 00:01:02,000
LLVM 主要是跟传统的编译系的电影一样

23
00:01:02,000 --> 00:01:03,320
分开前端

24
00:01:03,320 --> 00:01:04,240
中间优化层

25
00:01:04,240 --> 00:01:05,200
还有后端

26
00:01:05,200 --> 00:01:07,320
而中间的每一个箭头

27
00:01:07,320 --> 00:01:09,520
代表的是一个 IR 的转换

28
00:01:09,520 --> 00:01:11,160
可以看到在 LLVM 的架构里面

29
00:01:11,160 --> 00:01:13,120
不管是前端优化层

30
00:01:13,120 --> 00:01:15,200
还有后端都会有大量的 IR

31
00:01:15,200 --> 00:01:17,560
使得 LLVM 的模块化程度非常高

32
00:01:17,560 --> 00:01:20,200
可以大量的去附用一些相同的代码

33
00:01:20,200 --> 00:01:23,560
非常方便集成到不同的 ID 和其他编译器当中

34
00:01:25,720 --> 00:01:27,320
下面来看看第一个内容

35
00:01:27,320 --> 00:01:29,600
就是 LLVM 的 IR 中间表达

36
00:01:29,600 --> 00:01:32,920
左边的这个图就是 GCC 的一个表示方式

37
00:01:32,920 --> 00:01:35,360
它把前端跟后端其实已经怼到一起了

38
00:01:35,360 --> 00:01:39,280
没有明确的去把编译系的前端优化系和后端分开

39
00:01:39,280 --> 00:01:40,520
而 LLVM 的 IR

40
00:01:40,520 --> 00:01:42,800
遵从了刚才讲的编译系的基本概念

41
00:01:42,800 --> 00:01:44,200
把前端分开出来

42
00:01:44,200 --> 00:01:45,440
然后中间通过 IR

43
00:01:45,440 --> 00:01:47,200
把不同的优化系的 part 串起来

44
00:01:47,200 --> 00:01:48,920
最后就是后端的优化

45
00:01:50,560 --> 00:01:54,640
这并不意味着 LLVM
只使用一个单一的 IR 进行表达

46
00:01:54,640 --> 00:01:56,880
LLVM 的 IR 还是非常丰富的

47
00:01:56,920 --> 00:02:00,160
首先前端编译的时候传给中间优化层的时候

48
00:02:00,160 --> 00:02:02,600
它传的是一个 AST 的 IR

49
00:02:02,600 --> 00:02:04,040
那 AST 也作为一种 IR

50
00:02:04,040 --> 00:02:05,760
因为 IR 是个中间表达

51
00:02:05,760 --> 00:02:08,000
它没有一个固定的形态

52
00:02:08,000 --> 00:02:11,120
接着中间会有非常多的 IR 进行传递

53
00:02:11,120 --> 00:02:13,560
可能这些 IR 之间会有所差异

54
00:02:13,560 --> 00:02:15,160
也可能会是相同的

55
00:02:15,160 --> 00:02:16,280
那优化完之后

56
00:02:16,280 --> 00:02:19,080
它会传一个 DAG 图给后端

57
00:02:19,080 --> 00:02:21,440
为什么会用 DAG 图传给后端呢

58
00:02:21,440 --> 00:02:26,200
因为 DAG 图能够非常有效的去表示硬件的指定的顺序

59
00:02:26,240 --> 00:02:27,480
而在后端的优化的时候

60
00:02:27,480 --> 00:02:30,880
它可能又转回普通的 IR 进行一个优化

61
00:02:30,880 --> 00:02:32,600
最后再生成机器码

62
00:02:32,600 --> 00:02:34,560
这里面想表达的一个概念就是

63
00:02:34,560 --> 00:02:35,920
在编译不同的阶段

64
00:02:35,920 --> 00:02:37,840
会采用不同的数据结构

65
00:02:37,840 --> 00:02:39,520
不同的中间表达

66
00:02:39,520 --> 00:02:41,560
而中间表达说实话

67
00:02:41,560 --> 00:02:46,640
它就是一个人类或者所定义的特殊的数据结构

68
00:02:49,240 --> 00:02:50,040
Text 的函数

69
00:02:50,040 --> 00:02:51,880
Text 的函数里面其实比较简单

70
00:02:51,880 --> 00:02:54,560
int c 等于 a 乘以 b 加上 100

71
00:02:54,560 --> 00:02:58,560
然后使用 clang-c-emit-LLVM-text-c

72
00:02:58,560 --> 00:03:00,440
这一个 cpp 文件

73
00:03:00,440 --> 00:03:03,120
然后可以看到输出的 LLVM 的 IR

74
00:03:05,000 --> 00:03:07,680
LLVM IR 里面的分号代表的是一个注释

75
00:03:07,680 --> 00:03:09,760
所以看到分号里面基本上可以不用管

76
00:03:09,760 --> 00:03:12,600
这个分号里面后面的都是一个代表具体的注释

77
00:03:13,160 --> 00:03:14,080
全区的变量

78
00:03:14,080 --> 00:03:15,160
用 at 开头

79
00:03:15,160 --> 00:03:16,160
而局部的变量

80
00:03:16,160 --> 00:03:17,720
以百分号作为开头

81
00:03:17,720 --> 00:03:19,280
所以看到百分号 3

82
00:03:19,280 --> 00:03:19,960
百分号 4

83
00:03:19,960 --> 00:03:20,600
百分号 5

84
00:03:20,600 --> 00:03:22,000
都是局部的变量

85
00:03:22,040 --> 00:03:24,000
IR 里面的 alloc start load

86
00:03:24,000 --> 00:03:24,880
mod add

87
00:03:24,880 --> 00:03:25,880
align i t

88
00:03:25,880 --> 00:03:28,040
这些都是明确的一个具体的指令

89
00:03:28,680 --> 00:03:31,360
这里面可以看到出现大量的 i32

90
00:03:31,360 --> 00:03:34,320
i32 主要是表示 32 位四个字节

91
00:03:34,760 --> 00:03:36,040
下面 1234567

92
00:03:36,040 --> 00:03:37,320
就是 IR 的基本语法

93
00:03:37,320 --> 00:03:39,120
刚才以一个简单的例子

94
00:03:39,120 --> 00:03:40,360
给大家讲了一下

95
00:03:40,360 --> 00:03:41,360
具体的这些语法

96
00:03:41,360 --> 00:03:43,320
在 IR 当中是怎么样去表示的

97
00:03:43,960 --> 00:03:45,120
LLVM IR 里面

98
00:03:45,120 --> 00:03:47,280
主要是有两个基本的原则指导的

99
00:03:47,280 --> 00:03:49,080
整个 LLVM 核心的库

100
00:03:49,080 --> 00:03:51,840
叫做 LLVM Code 来去开发的

101
00:03:51,960 --> 00:03:52,920
这两个基本原则

102
00:03:53,080 --> 00:03:55,200
第一个就是 SSA 表示

103
00:03:55,200 --> 00:03:57,160
SSA 是静态单赋值

104
00:03:57,160 --> 00:03:58,960
会在后面去介绍的

105
00:03:58,960 --> 00:04:00,720
SSA 使得代码

106
00:04:00,840 --> 00:04:02,680
组织为三地址指令序列

107
00:04:02,680 --> 00:04:04,680
还有无线的一个寄存器

108
00:04:04,680 --> 00:04:06,160
还有无线寄存器的概念

109
00:04:06,160 --> 00:04:07,960
使得整个编译器的优化

110
00:04:07,960 --> 00:04:09,920
可以更快速的去执行

111
00:04:09,920 --> 00:04:11,480
第二个就是整个程序的

112
00:04:11,480 --> 00:04:12,880
IR 存储到磁盘里面

113
00:04:12,880 --> 00:04:14,920
想要加载的时候就加载

114
00:04:14,920 --> 00:04:16,360
想要链接的时候就链接

115
00:04:16,360 --> 00:04:17,680
所以使得编译优化

116
00:04:17,680 --> 00:04:18,560
还有 JIT 优化

117
00:04:18,560 --> 00:04:19,800
更容易的去实现

118
00:04:19,800 --> 00:04:20,760
执行的更快

119
00:04:22,240 --> 00:04:24,040
下面了解刚才讲到的

120
00:04:24,040 --> 00:04:25,120
第一条原则

121
00:04:25,400 --> 00:04:26,760
LMVM 的 IR 采用

122
00:04:26,760 --> 00:04:28,040
静态单赋值的形式

123
00:04:28,040 --> 00:04:30,920
也就是 Static Single Assignment SSA

124
00:04:30,920 --> 00:04:32,520
里面具有两个重要的原则

125
00:04:32,520 --> 00:04:33,880
刚才简单的提了

126
00:04:33,880 --> 00:04:35,720
第一个就是把代码组织为

127
00:04:35,720 --> 00:04:37,600
三地址的一个指令序列

128
00:04:37,600 --> 00:04:39,200
第二个就是指令寄存器的

129
00:04:39,200 --> 00:04:40,560
数量是无限的

130
00:04:41,720 --> 00:04:43,160
首先从下往上看

131
00:04:43,160 --> 00:04:44,440
为什么寄存器的数量

132
00:04:44,440 --> 00:04:46,320
要无限制在 IR 这一层

133
00:04:46,320 --> 00:04:48,160
因为 IR 它只是一个中间表达

134
00:04:48,160 --> 00:04:50,880
不希望跟后端的硬件相绑定

135
00:04:50,920 --> 00:04:52,960
硬件的寄存器的造价还是很贵的

136
00:04:52,960 --> 00:04:54,160
所以每一款芯片

137
00:04:54,160 --> 00:04:55,680
寄存器的数量是有限的

138
00:04:55,680 --> 00:04:57,360
但是在 IR 中间表达这一层

139
00:04:57,480 --> 00:04:58,880
是一个存软件

140
00:04:58,880 --> 00:05:00,640
存数据结构的表示

141
00:05:00,640 --> 00:05:02,680
所以为了避免跟硬件相关

142
00:05:02,680 --> 00:05:04,320
这里面假设寄存器的数量

143
00:05:04,320 --> 00:05:05,520
是无限制的

144
00:05:09,560 --> 00:05:11,560
下面来看看什么叫做

145
00:05:11,560 --> 00:05:15,040
Static Single Assignment 静态单赋值

146
00:05:15,480 --> 00:05:17,080
其实了解这个基本概念

147
00:05:17,080 --> 00:05:18,360
还是比较简单的

148
00:05:18,360 --> 00:05:19,680
就是程序中每个变量

149
00:05:19,680 --> 00:05:22,080
都有且只有一个赋值语句

150
00:05:22,640 --> 00:05:24,600
下面以 1x2 加 3

151
00:05:24,600 --> 00:05:27,520
作为 LLVM IR 的一个例子来看看

152
00:05:27,720 --> 00:05:29,680
现在定一个局部变量

153
00:05:29,680 --> 00:05:30,960
1x2

154
00:05:31,160 --> 00:05:33,600
接着再定一个局部变量

155
00:05:33,600 --> 00:05:35,840
把刚才 1x2 的结果加上 3

156
00:05:35,840 --> 00:05:38,480
然后再返回局部变量 0

157
00:05:38,480 --> 00:05:40,040
但是这里面有一个问题

158
00:05:40,040 --> 00:05:41,800
采用的是一个静态单赋值

159
00:05:41,800 --> 00:05:42,800
也就是每个变量

160
00:05:42,800 --> 00:05:44,400
都只能有一个赋值语句

161
00:05:44,400 --> 00:05:46,440
所以百分号 0 就不能复用

162
00:05:46,440 --> 00:05:47,880
只能用百分号 1

163
00:05:47,880 --> 00:05:49,320
来去表示 1x2

164
00:05:49,320 --> 00:05:51,320
再加上 3 的最后的结果

165
00:05:51,320 --> 00:05:52,800
然后返回百分号 1

166
00:05:53,320 --> 00:05:55,200
ZOMI 老师我就有一个问题了

167
00:05:55,200 --> 00:05:57,120
为什么需要静态单赋值

168
00:05:57,120 --> 00:05:58,360
或者 SSA 呢

169
00:05:58,360 --> 00:05:59,720
它有什么好处吗

170
00:06:00,560 --> 00:06:03,320
其实这么设计是有两个好处的

171
00:06:03,320 --> 00:06:05,280
第一个可以反向的追溯到

172
00:06:05,280 --> 00:06:06,800
定义的唯一一个指令

173
00:06:06,800 --> 00:06:09,080
百分号 0 对应的是这条指令

174
00:06:09,080 --> 00:06:11,240
百分号 1 对应的是这一条指令

175
00:06:11,400 --> 00:06:12,960
如果定义的都是百分号 0

176
00:06:12,960 --> 00:06:15,480
怎么知道对应的是哪一条指令呢

177
00:06:15,680 --> 00:06:17,840
这种方式就非常方便于编译器

178
00:06:17,840 --> 00:06:19,840
做正向和反向的编译

179
00:06:20,280 --> 00:06:21,320
第二个好处就是

180
00:06:21,320 --> 00:06:23,360
极大地简化整个的优化过程

181
00:06:23,360 --> 00:06:24,440
因为 SSA 呢

182
00:06:24,440 --> 00:06:25,800
它会建立一个平凡的

183
00:06:25,800 --> 00:06:27,120
user defined 的一个链

184
00:06:27,120 --> 00:06:29,200
就是使用和定义的一个链条

185
00:06:29,520 --> 00:06:31,200
有了 user defined 这个链条

186
00:06:31,200 --> 00:06:32,400
可以很方便地去追溯

187
00:06:32,400 --> 00:06:33,440
每个值

188
00:06:33,440 --> 00:06:35,440
它对应的指令是怎么去使用的

189
00:06:36,040 --> 00:06:36,920
下面来看看

190
00:06:36,920 --> 00:06:39,840
LLVM IR 的一个基本的语法规则

191
00:06:40,240 --> 00:06:42,600
LLVM IR 是一类似于一个

192
00:06:42,600 --> 00:06:43,480
精简指令集

193
00:06:43,480 --> 00:06:44,480
也就是 VISCA 的一个

194
00:06:44,480 --> 00:06:45,840
底层虚拟的指令集

195
00:06:45,920 --> 00:06:47,520
但是它也只是一个类似

196
00:06:47,520 --> 00:06:49,400
而并不是真正的一个指令集

197
00:06:49,960 --> 00:06:52,320
LLVM IR 既然类似于真正的指令集

198
00:06:52,440 --> 00:06:53,600
它跟真正的指令集

199
00:06:53,720 --> 00:06:55,480
肯定会有一些相似的地方

200
00:06:55,720 --> 00:06:58,120
相似的地方就是同样去支持一些

201
00:06:58,120 --> 00:07:00,000
简单的指令的新型的序列

202
00:07:00,000 --> 00:07:02,080
例如添加相减比较分支

203
00:07:02,400 --> 00:07:04,000
刚才就是 add mod

204
00:07:04,000 --> 00:07:05,200
这些就是类似于

205
00:07:05,200 --> 00:07:06,680
精简的指令集的方式

206
00:07:07,000 --> 00:07:09,400
第二个就是指令都是三地址形式的

207
00:07:09,400 --> 00:07:10,320
刚才在讲

208
00:07:10,720 --> 00:07:12,560
LLVM IR 的一个基本原则的时候

209
00:07:12,560 --> 00:07:13,920
也介绍过三地址指令

210
00:07:13,920 --> 00:07:15,720
将会在后面去介绍的

211
00:07:15,840 --> 00:07:17,720
它们可以接受一定数量的输入

212
00:07:18,240 --> 00:07:19,840
然后在不同的继承器里面

213
00:07:19,840 --> 00:07:21,720
存储不同的计算结果

214
00:07:22,640 --> 00:07:25,520
第三个就是跟大部分精简指令集不同

215
00:07:25,520 --> 00:07:26,880
因为 LLVM IR 作为一个

216
00:07:26,880 --> 00:07:28,560
数据结构和软件的定义

217
00:07:29,360 --> 00:07:31,960
使用了墙类型剥离了机器的差异

218
00:07:31,960 --> 00:07:33,080
也就是我不用去管

219
00:07:33,080 --> 00:07:34,640
硬件到底有多少个指令

220
00:07:34,640 --> 00:07:36,600
不同的硬件其实有不同的指令

221
00:07:36,600 --> 00:07:38,320
也有不同数量的继承器

222
00:07:39,760 --> 00:07:40,800
最后一个就是

223
00:07:40,800 --> 00:07:43,800
LLVM IR 不使用固定的命名的继承器

224
00:07:43,800 --> 00:07:44,840
因为每个继承器

225
00:07:44,840 --> 00:07:46,280
或者每个类型的继承器

226
00:07:46,280 --> 00:07:47,240
都有自己的地址

227
00:07:47,240 --> 00:07:48,480
都有自己的名字

228
00:07:48,480 --> 00:07:51,040
LLVM IR 统一以百分号

229
00:07:51,040 --> 00:07:53,240
所有都叫做临时继承器

230
00:07:56,760 --> 00:07:59,920
刚才已经第三次提到三地址指令了

231
00:07:59,920 --> 00:08:01,120
那三地址指令

232
00:08:01,120 --> 00:08:02,280
在英文里面叫做

233
00:08:02,280 --> 00:08:03,760
Three Address Codes

234
00:08:03,760 --> 00:08:05,120
就是三地址指令

235
00:08:05,120 --> 00:08:06,800
直译过来的完全是

236
00:08:07,560 --> 00:08:08,800
每个三地址指令

237
00:08:08,800 --> 00:08:10,480
都可以被分解为一个四元组

238
00:08:10,480 --> 00:08:11,800
叫做 Four Tuples

239
00:08:12,600 --> 00:08:13,600
这个 Four Tuples

240
00:08:13,600 --> 00:08:14,880
这个四代表的就是

241
00:08:14,880 --> 00:08:17,000
运算服操作数一操作数二

242
00:08:17,000 --> 00:08:17,960
还有结果

243
00:08:17,960 --> 00:08:20,720
也就是我的操作数一跟操作数二

244
00:08:20,720 --> 00:08:22,320
执行了操作运算服之后

245
00:08:22,480 --> 00:08:24,000
我得到一个结果

246
00:08:24,880 --> 00:08:27,040
以 J 等于 S 加 Y 这个复制指令

247
00:08:27,160 --> 00:08:27,760
去表示

248
00:08:27,920 --> 00:08:29,200
四元组的表示就是

249
00:08:29,200 --> 00:08:31,320
X 加 Y 等于 Z

250
00:08:33,000 --> 00:08:35,280
了解完 LLVM IR 的设计原则

251
00:08:35,280 --> 00:08:36,680
还有它的基本语法规则了

252
00:08:36,680 --> 00:08:37,640
可以看一下

253
00:08:37,640 --> 00:08:39,240
LLVM 输出的时候

254
00:08:39,400 --> 00:08:40,600
它有三种形式

255
00:08:40,760 --> 00:08:43,360
第一种就是直接变成内存的

256
00:08:43,360 --> 00:08:44,200
中间语言

257
00:08:44,200 --> 00:08:44,640
这个时候

258
00:08:44,800 --> 00:08:47,000
这些中间语言是内存的数据结构

259
00:08:47,000 --> 00:08:49,760
没有办法通过文件的形式去取的

260
00:08:49,760 --> 00:08:51,640
因为它都是一些指令类型

261
00:08:52,000 --> 00:08:53,920
第二种就是直接存在硬盘里面的

262
00:08:53,920 --> 00:08:55,080
二进制的中间语言

263
00:08:55,240 --> 00:08:56,400
这个叫做 BC

264
00:08:56,400 --> 00:08:57,240
在命令行里面

265
00:08:57,320 --> 00:08:58,800
可以通过 OD 去查询

266
00:08:59,080 --> 00:09:01,800
第三种就是人类可以读的代码语言

267
00:09:01,800 --> 00:09:02,560
.LL

268
00:09:02,560 --> 00:09:04,480
刚才我给大家去呈现的

269
00:09:04,760 --> 00:09:06,600
LLVM IR 这种可呈现的方式

270
00:09:06,760 --> 00:09:08,400
就是 LL 的表示方式

271
00:09:09,320 --> 00:09:13,680
刚才了解 LLVM IR 了

272
00:09:14,120 --> 00:09:16,360
只是了解 LLVM IR 的设计原则

273
00:09:16,360 --> 00:09:18,120
还有它的一个数据结构的定义

274
00:09:18,120 --> 00:09:20,280
如果想在编译器的优化层

275
00:09:20,280 --> 00:09:22,360
去对 LLVM 的 IR 进行操作

276
00:09:23,080 --> 00:09:24,800
写一个自己想要的一个优化 pass

277
00:09:24,960 --> 00:09:26,640
这个时候就需要去了解

278
00:09:26,640 --> 00:09:28,520
LLVM IR 的一个内存模型

279
00:09:28,960 --> 00:09:31,440
LLVM IR 文件的一个最基本的单位了

280
00:09:31,440 --> 00:09:32,680
叫做 modules

281
00:09:33,160 --> 00:09:35,400
一个 modules 可以拥有很多不同的实体

282
00:09:35,400 --> 00:09:37,080
例如 function global variable

283
00:09:37,360 --> 00:09:40,280
其中 function define 最少至少有一个 box

284
00:09:40,280 --> 00:09:41,560
也就可以拥有多个

285
00:09:41,560 --> 00:09:43,680
每个 box 里面有非常多的 instruction

286
00:09:43,680 --> 00:09:45,280
也有很多的不同的指令

287
00:09:45,560 --> 00:09:47,400
最后都以 termination instruction

288
00:09:47,400 --> 00:09:48,400
作为一个结尾

289
00:09:48,840 --> 00:09:50,480
现在以刚才讲的一个例子

290
00:09:50,680 --> 00:09:51,600
去解读一下

291
00:09:52,480 --> 00:09:54,680
这个文件所有的叫做一个 modules

292
00:09:54,680 --> 00:09:56,600
而一个 modules 有一个 function

293
00:09:56,720 --> 00:09:58,440
这个 function 有一个 basic block

294
00:09:58,440 --> 00:10:00,880
这个 basic block 有若干条指令组成

295
00:10:01,000 --> 00:10:03,360
可以看到里面有 store, load, mode, add

296
00:10:03,360 --> 00:10:04,840
有多个指令组成

297
00:10:05,240 --> 00:10:06,680
最后以 termination instruction

298
00:10:06,680 --> 00:10:09,160
作为一个结束 ret 去返回

299
00:10:09,960 --> 00:10:11,480
总体横向的去看看

300
00:10:11,480 --> 00:10:12,840
最上层有 modules

301
00:10:12,840 --> 00:10:13,560
有 function

302
00:10:13,560 --> 00:10:14,200
有 basic block

303
00:10:14,200 --> 00:10:15,960
有 instruction 去组成

304
00:10:16,240 --> 00:10:19,120
每一种这些都是需要去了解的概念

305
00:10:19,360 --> 00:10:20,480
在实际写代码的时候

306
00:10:20,680 --> 00:10:22,680
去大量的去用到这些对象和类

307
00:10:23,760 --> 00:10:27,520
LLVM IR 刚才
只是介绍了一个大颗粒度的模块

308
00:10:27,520 --> 00:10:29,040
像这些刚才的 instruction

309
00:10:29,040 --> 00:10:30,480
是刚才介绍的模块

310
00:10:30,480 --> 00:10:32,240
实际上里面最重要的概念

311
00:10:32,240 --> 00:10:34,200
value, use 还有 user

312
00:10:34,880 --> 00:10:38,320
所有的方法都是来自于 LLVM values 的一个定义

313
00:10:38,320 --> 00:10:39,760
有了这整套数据结构

314
00:10:39,880 --> 00:10:41,560
就可以非常方便去操作

315
00:10:41,560 --> 00:10:43,240
LLVM IR 内存模型里面的

316
00:10:43,240 --> 00:10:45,240
user define 和 define user 的这条链

317
00:10:45,920 --> 00:10:47,120
大家不理解这个概念

318
00:10:47,120 --> 00:10:48,560
其实还是没有关系的

319
00:10:48,560 --> 00:10:50,080
因为希望大家能够了解

320
00:10:50,080 --> 00:10:52,480
LLVM 编译器的一个最基本的结构

321
00:10:52,480 --> 00:10:54,320
还有它的一些基本的流程

322
00:10:54,320 --> 00:10:56,080
未来以后可能有机会

323
00:10:56,080 --> 00:10:57,440
去写一些 AI 编译器

324
00:10:57,440 --> 00:10:59,400
或者参与到 AI 编译器的项目里面

325
00:11:00,120 --> 00:11:02,120
你才会有一个更加深入的体会

326
00:11:03,120 --> 00:11:05,120
卷的不行了，卷的不行了

327
00:11:05,120 --> 00:11:07,120
记得一键三连加关注哦

328
00:11:07,120 --> 00:11:09,120
所有的内容都会开源在

329
00:11:09,120 --> 00:11:11,120
下面这条链接里面

330
00:11:11,120 --> 00:11:13,120
拜了个掰

