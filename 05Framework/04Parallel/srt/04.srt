1
00:00:00,140 --> 00:00:04,700
字幕生成: 粟君杰字幕校对: 粟君杰

2
00:00:04,800 --> 00:00:05,520
hello

3
00:00:05,520 --> 00:00:06,150
大家好

4
00:00:06,150 --> 00:00:07,230
我是 ZOMI

5
00:00:07,230 --> 00:00:10,020
这一节的内容呢，还是张量并行

6
00:00:10,020 --> 00:00:15,200
不同的是去讲讲张量并行里面的张量重排

7
00:00:15,200 --> 00:00:17,870
然后呢，再去拓展一下 MindSpore

8
00:00:17,870 --> 00:00:21,140
如何去对张量做自动重排

9
00:00:21,140 --> 00:00:22,900
的一个具体的算法

10
00:00:24,920 --> 00:00:26,800
现在呢，来到最后一个内容

11
00:00:26,800 --> 00:00:28,720
也就是 MindSpore 很重要的一个特性

12
00:00:28,720 --> 00:00:29,920
张量自动运行

13
00:00:29,920 --> 00:00:33,220
来先先看看具体的数学原理吧

14
00:00:33,220 --> 00:00:36,240
首先回顾一下一个张量呢

15
00:00:36,240 --> 00:00:37,920
现在的一个 2x2 的张量

16
00:00:37,920 --> 00:00:39,900
把它切换到两台不同的机器

17
00:00:39,900 --> 00:00:41,580
那可能有两种切换方式

18
00:00:41,580 --> 00:00:43,080
一种是行的切分

19
00:00:43,080 --> 00:00:44,280
一种是列的切分

20
00:00:44,280 --> 00:00:46,440
另外一种就是直接复制

21
00:00:46,440 --> 00:00:48,060
那假设我复杂一点

22
00:00:48,060 --> 00:00:49,560
我的机器多了

23
00:00:49,560 --> 00:00:51,620
我同样是一个 2x2 的机器

24
00:00:51,620 --> 00:00:53,480
我现在有四台设备

25
00:00:53,480 --> 00:00:56,120
我可能会进行一个行列的切分

26
00:00:56,120 --> 00:00:58,400
把每一个元素切分到不同的机器

27
00:00:58,400 --> 00:01:00,950
我也可能只进行一个行的切分

28
00:01:00,950 --> 00:01:03,020
或者只进行一个行的切分

29
00:01:03,020 --> 00:01:05,900
那我有四台机器行切换只会分成两半

30
00:01:05,900 --> 00:01:08,240
所以另外两半呢，会做一个复制

31
00:01:08,240 --> 00:01:12,530
这个 Device 1 跟 Device 3 的数据是相同的

32
00:01:12,530 --> 00:01:15,100
第三种就是进行列的切分

33
00:01:15,100 --> 00:01:18,850
同样列的切分呢，只会切分成两组数据

34
00:01:18,850 --> 00:01:21,140
我还是需要进行一个复制

35
00:01:21,140 --> 00:01:24,050
把 Device 1 的数据复制成 Device 3

36
00:01:24,050 --> 00:01:26,960
我才可以保证四台机器都有数据

37
00:01:26,960 --> 00:01:29,330
最后一种方式呢，就是全复制

38
00:01:29,330 --> 00:01:32,240
把一个矩阵复制到所有的机器

39
00:01:32,240 --> 00:01:35,380
既然有各种的切换方式

40
00:01:35,380 --> 00:01:40,060
就会涉及到各种的通信方式啦

41
00:01:40,880 --> 00:01:41,980
提到通信方式

42
00:01:41,980 --> 00:01:45,250
大家可以看一下我之前分享的一个内容

43
00:01:45,250 --> 00:01:46,840
就是通信原语哦

44
00:01:46,840 --> 00:01:49,740
不不不是，是通信原理啊

45
00:01:49,740 --> 00:01:53,120
其实刚才讲的各种的切分方式呢

46
00:01:53,120 --> 00:01:54,680
可以互相转换的

47
00:01:54,680 --> 00:01:57,740
可以通过 slice，All-Gather 或者 All-to-All

48
00:01:57,740 --> 00:02:00,050
不同的方式进行切换

49
00:02:00,050 --> 00:02:01,880
同样我有四台四倍

50
00:02:01,880 --> 00:02:05,420
刚才的几种方式也可以通过 All-Gather，All-Reduce

51
00:02:05,420 --> 00:02:06,200
还有 slice

52
00:02:06,200 --> 00:02:11,100
还有 All-to-All 这几种切分方式进行互相转化的

53
00:02:11,800 --> 00:02:13,470
讲这个有什么用呢

54
00:02:13,470 --> 00:02:16,200
是因为在整个神经网络模型里面呢

55
00:02:16,200 --> 00:02:19,800
会大量的去用到这些内容

56
00:02:20,560 --> 00:02:24,180
那假设呢，现在我引入了一个新的概念

57
00:02:24,180 --> 00:02:25,940
叫做张量重排

58
00:02:25,940 --> 00:02:28,730
Tensor Redistribution

59
00:02:28,730 --> 00:02:30,740
现在举一个简单的例子

60
00:02:30,740 --> 00:02:32,750
假设我现在有两个计算

61
00:02:32,750 --> 00:02:34,780
一个 X 乘以 A 等于 Y

62
00:02:34,780 --> 00:02:37,030
第二个是我把 Y 作为输入

63
00:02:37,030 --> 00:02:38,650
Y 乘以 B 等于 Z

64
00:02:38,650 --> 00:02:43,120
那有点像刚才 Transformer 的 MLP 层

65
00:02:43,220 --> 00:02:45,200
在网络模型里面呢

66
00:02:45,200 --> 00:02:47,840
我的 X 的输入其实已经切分了四半

67
00:02:47,840 --> 00:02:49,100
有 X1 X2 X3 X4 

68
00:02:49,100 --> 00:02:52,140
而我的权重 A 呢，还是只有一份

69
00:02:52,140 --> 00:02:55,760
那我得到的就是一个 Y1 Y2 Y3 Y4

70
00:02:55,760 --> 00:02:59,810
下一层的网络模型呢，只接收一个 Y 的数

71
00:02:59,810 --> 00:03:03,270
那我就需要对不同的设备的 Y 做一个 All-Gather

72
00:03:03,270 --> 00:03:06,140
就把张量进行重新排列

73
00:03:06,140 --> 00:03:07,760
得到一个新的张量

74
00:03:07,760 --> 00:03:09,320
然后再进行计算的

75
00:03:09,320 --> 00:03:12,280
这个时候我的 B 呢，经按照列的方式切换好了

76
00:03:12,280 --> 00:03:13,240
Y1 乘以 B1 

77
00:03:13,240 --> 00:03:15,310
最后得到我的 Z1 Z2 Z3 Z4

78
00:03:15,310 --> 00:03:18,840
那中间的这个过程呢叫做张量重排

79
00:03:18,840 --> 00:03:21,480
再来看看另外一个概念

80
00:03:21,480 --> 00:03:24,030
假设我的计算公式还是一模一样的

81
00:03:24,030 --> 00:03:25,720
X 乘以 A 等于 Y

82
00:03:25,720 --> 00:03:28,240
那 Y 呢作为 Z 的输入

83
00:03:28,240 --> 00:03:30,880
Y 乘以 B 等于 Z

84
00:03:30,980 --> 00:03:34,360
上一层网络模型传给数据呢

85
00:03:34,360 --> 00:03:37,140
就不是 X 每一个进行切分

86
00:03:37,140 --> 00:03:39,520
而是 X 进行行切分

87
00:03:39,520 --> 00:03:41,140
A 进行列千分

88
00:03:41,140 --> 00:03:44,500
所以 Device 1 呢，是 X1；Device 2 还是 X1 

89
00:03:44,500 --> 00:03:45,100
Device 3 呢，

90
00:03:45,100 --> 00:03:46,620
是 X2 

91
00:03:46,620 --> 00:03:49,530
而 A 呢，Device 1 是 A1 

92
00:03:49,530 --> 00:03:50,100
Device 2 呢，

93
00:03:50,100 --> 00:03:51,390
是 A2 

94
00:03:51,390 --> 00:03:54,880
那这个时候我的计算模型就不一样了

95
00:03:54,880 --> 00:03:58,420
中间呢，这时候就不需要一个 All-Gather 的方式

96
00:03:58,420 --> 00:04:00,160
把所有的 Y 进行聚合

97
00:04:00,160 --> 00:04:02,290
因为 Y 需不需要聚合

98
00:04:02,290 --> 00:04:04,540
取决于后面的计算

99
00:04:04,540 --> 00:04:08,200
那后面的 B 呢，我是按照行进行切分的

100
00:04:08,200 --> 00:04:11,320
我按照行进行切分到不同的机器进行复制

101
00:04:11,320 --> 00:04:12,820
最后再进行计算

102
00:04:12,820 --> 00:04:17,399
那我期望得到的是 Z1 Z2，Y 乘以 B 之后呢

103
00:04:17,399 --> 00:04:19,379
需要做一个 All-Reduce 的操作

104
00:04:19,379 --> 00:04:21,660
然后聚合得到我的 Z1 

105
00:04:21,660 --> 00:04:24,420
同理这个 Y 进行 All-Reduce 操作

106
00:04:24,420 --> 00:04:26,080
得到我的 Z2 

107
00:04:26,080 --> 00:04:27,550
这种操作

108
00:04:27,550 --> 00:04:31,240
也作为张量重排的其中一种特殊的形态

109
00:04:31,240 --> 00:04:34,200
这么做有什么好处呢

110
00:04:34,420 --> 00:04:37,320
张量重排其实是一个很复杂的工程

111
00:04:37,320 --> 00:04:40,280
我需要知道很多种不同的排列方式

112
00:04:40,280 --> 00:04:43,850
然后为系统找到一种最优的执行效率

113
00:04:43,850 --> 00:04:45,980
所以 Mindspore 这个 ai 框架

114
00:04:45,980 --> 00:04:48,920
就发明了一个张量切片的一个策略

115
00:04:48,920 --> 00:04:51,720
就是利用刚才张量重排的一个原理

116
00:04:51,720 --> 00:04:54,780
那可能里面的算法分为四部分

117
00:04:54,780 --> 00:04:58,320
第一步呢，就是拿到网络模型定义的脚本

118
00:04:58,320 --> 00:05:00,660
通过源码转换得到计算图

119
00:05:00,660 --> 00:05:05,520
第二步呢就是对每一个算子去枚举

120
00:05:05,520 --> 00:05:07,380
它可能的切分方式

121
00:05:07,380 --> 00:05:10,740
假设 ReLU 呢，有很多种不同的切分方式

122
00:05:10,740 --> 00:05:11,820
有按行切分

123
00:05:11,820 --> 00:05:13,260
有按列切分

124
00:05:13,260 --> 00:05:14,280
假设是 ReLU

125
00:05:14,280 --> 00:05:16,680
它有按行的第八行进行切分

126
00:05:16,680 --> 00:05:18,520
它有按第四行进行切分

127
00:05:18,520 --> 00:05:20,200
也有按第四列进行切分

128
00:05:20,200 --> 00:05:21,760
或者第八列进行切分

129
00:05:21,760 --> 00:05:23,260
切分的策略非常多

130
00:05:23,260 --> 00:05:24,920
会进行一个枚举

131
00:05:24,920 --> 00:05:25,880
第三步呢

132
00:05:25,880 --> 00:05:28,430
系统就会去枚举计算图里面

133
00:05:28,430 --> 00:05:32,430
每一条边经过张量重排之后的具体的策略

134
00:05:32,430 --> 00:05:34,260
还有相对应的代价

135
00:05:34,260 --> 00:05:37,120
那这个呢，叫做 cos 这个代价函数

136
00:05:37,120 --> 00:05:40,870
第四步呢，就是通过凸优化或者动态规划的方法

137
00:05:40,870 --> 00:05:43,720
去求解最优的代价函数

138
00:05:43,720 --> 00:05:46,020
就是最优的 cost 函数

139
00:05:46,020 --> 00:05:49,740
到最后一步就是把刚才求得到的一个策略

140
00:05:49,740 --> 00:05:51,200
从算子进行出发

141
00:05:51,200 --> 00:05:53,000
传播到整个网络

142
00:05:53,000 --> 00:05:55,280
然后去进行运算

143
00:05:55,980 --> 00:05:57,800
今天的内容呢，稍微多了一点

144
00:05:57,800 --> 00:05:58,760
来总结一下

145
00:05:58,760 --> 00:06:00,220
我还了解了 mindspore

146
00:06:00,220 --> 00:06:03,070
张量自动并行的具体的策略原理

147
00:06:03,070 --> 00:06:04,000
卷的不行了

148
00:06:04,000 --> 00:06:04,900
卷的不行了

149
00:06:04,900 --> 00:06:06,520
记得一键三连加关注哦

150
00:06:06,520 --> 00:06:08,080
所有的内容都会开源

151
00:06:08,080 --> 00:06:10,960
在下面这条链接里面拜了个拜